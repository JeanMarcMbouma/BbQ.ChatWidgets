# Architecture Guide

BbQ.ChatWidgets is designed as a distributed system that coordinates between a .NET backend and a JavaScript-based frontend. This guide explains the core components and the data flow between them.

## High-Level Overview

The system follows a "Server-Driven UI" pattern for chat. The LLM decides which widgets are appropriate for the conversation, and the server provides the metadata and templates required for the frontend to render them.

### Core Components

#### 1. Server-Side (.NET)

- **`ChatWidgetService`**: The central orchestrator. It manages conversation threads, interacts with the `IChatClient`, parses widget hints from AI responses, and dispatches widget actions.
- **`WidgetRegistry`**: A catalog of available widget templates. Each widget (e.g., `ButtonWidget`, `FormWidget`) is registered here as a live instance.
- **`IThreadService`**: Manages conversation history. The default implementation is in-memory (`DefaultThreadService`), but it can be replaced with a persistent store.
- **`IWidgetActionRegistry`**: Maps widget actions (e.g., "submit_form") to their corresponding server-side handlers.
- **`IAIInstructionProvider`**: Generates the system prompt that tells the LLM how to use widgets and what actions are available.

#### 2. Client-Side (JavaScript/TypeScript)

- **`WidgetManager`**: The primary entry point for rendering widgets. It maintains a registry of component renderers and handles the lifecycle of widgets in the DOM.
- **`WidgetSseManager`**: Handles real-time server-pushed updates for widgets via Server-Sent Events (SSE).
- **Action Dispatcher**: Forwards user interactions (like clicking a button or submitting a form) back to the server's `/api/chat/action` endpoint.

## Data Flow

### 1. Message Request
1. The frontend sends a `POST` request to `/api/chat/message` with the user's text.
2. `ChatWidgetService` retrieves the conversation history from `IThreadService`.
3. It calls the `IChatClient` (e.g., OpenAI) with the history and a system prompt generated by `IAIInstructionProvider`.
4. The LLM responds, potentially including `<widget>...</widget>` tags or calling the `get_widget_tools` function.
5. `ChatWidgetService` parses these hints, creates the widget metadata, and returns a `ChatTurn` object containing the text and the list of widgets.

### 2. Widget Action
1. The user interacts with a widget (e.g., clicks a "Confirm" button).
2. The frontend sends a `POST` request to `/api/chat/action` with the action name and payload.
3. `ChatWidgetService` resolves the appropriate handler via `IWidgetActionHandlerResolver`.
4. The handler executes (e.g., updates a database) and returns a response.
5. The response is appended to the conversation thread, and the updated state is returned to the client.

### 3. Streaming (SSE)
1. The frontend connects to `/api/chat/stream/message`.
2. The server streams `ChatTurn` deltas as they are generated by the LLM.
3. The final event in the stream contains the full `ChatTurn` with all resolved widgets.

## Extension Points

BbQ.ChatWidgets is highly extensible. You can swap out almost any component by providing your own implementation of the core interfaces:

- **Custom Widgets**: Implement `IChatWidget` and register it in the `WidgetRegistry`.
- **Custom Persistence**: Implement `IThreadService` to store conversations in SQL, NoSQL, or Redis.
- **Custom AI Logic**: Replace `IAIInstructionProvider` or `IAIToolsProvider` to change how the LLM is guided.
