{"hash":"ce24f29905dc5f5fb8c8ccfd706ff9199968792381a6eddb871cff2a76b71107","types":[{"exports":["ButtonWidget","CardWidget","ChatWidget","CustomWidgetComponent","CustomWidgetHtmlRenderer","CustomWidgetRenderer","CustomWidgetRendererConfig","DatePickerWidget","DropdownWidget","FileUploadWidget","FormWidget","ImageCollectionWidget","ImageWidget","InputWidget","MultiSelectWidget","ProgressBarWidget","SSR_WIDGET_RENDERER","SliderWidget","SsrWidgetRenderer","TextAreaWidget","ThemeSwitcherWidget","ToggleWidget","VERSION","WIDGET_EVENT_MANAGER_FACTORY","WidgetEventManager","WidgetEventManagerFactory","WidgetRegistryService","WidgetRendererComponent","WidgetTemplateContext","customWidgetRegistry","isComponentRenderer","isHtmlRenderer","isTemplateRenderer","ssrWidgetRendererFactory","widgetEventManagerFactoryProvider"],"facadeModuleId":"C:\\Users\\jm\\source\\repos\\BbQ.ChatWidgets\\js-angular\\dist\\tmp-typings\\index.d.ts","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/custom-widget-renderer.types.d.ts","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/widget-registry.service.d.ts","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/widget-di.tokens.d.ts","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/widget-renderer.component.d.ts","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/public_api.d.ts","C:\\Users\\jm\\source\\repos\\BbQ.ChatWidgets\\js-angular\\dist\\tmp-typings\\index.d.ts"],"name":"index.d","type":"chunk","dynamicImports":[],"fileName":"index.d.ts","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["Type","TemplateRef","*","InjectionToken","OnInit","AfterViewInit","OnDestroy","OnChanges","Injector","EnvironmentInjector","EventEmitter","ElementRef","ComponentRef","EmbeddedViewRef","SimpleChanges"],"@bbq-chat/widgets":["ChatWidget","IWidgetActionHandler","WidgetEventManager","SsrWidgetRenderer","ButtonWidget","CardWidget","DatePickerWidget","DropdownWidget","FileUploadWidget","FormWidget","ImageCollectionWidget","ImageWidget","InputWidget","MultiSelectWidget","ProgressBarWidget","SliderWidget","TextAreaWidget","ThemeSwitcherWidget","ToggleWidget","customWidgetRegistry"]},"imports":["@angular/core","@bbq-chat/widgets"],"modules":{"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/custom-widget-renderer.types.d.ts":{"code":"/**\n * Context provided to template-based custom widget renderers\n */\ninterface WidgetTemplateContext {\n    /**\n     * The widget instance being rendered\n     */\n    $implicit: ChatWidget;\n    /**\n     * The widget instance (alternative access)\n     */\n    widget: ChatWidget;\n    /**\n     * Emit a widget action\n     */\n    emitAction: (actionName: string, payload: unknown) => void;\n}\n/**\n * Interface for component-based custom widget renderers\n */\ninterface CustomWidgetComponent {\n    /**\n     * The widget instance to render\n     */\n    widget: ChatWidget;\n    /**\n     * Event emitter for widget actions (optional, will be set by the renderer)\n     */\n    widgetAction?: (actionName: string, payload: unknown) => void;\n}\n/**\n * Type for custom widget renderer functions that return HTML strings\n */\ntype CustomWidgetHtmlRenderer = (widget: ChatWidget) => string;\n/**\n * Type for custom widget renderer configurations\n */\ntype CustomWidgetRenderer = CustomWidgetHtmlRenderer | Type<CustomWidgetComponent> | TemplateRef<WidgetTemplateContext>;\n/**\n * Configuration for registering a custom widget renderer\n */\ninterface CustomWidgetRendererConfig {\n    /**\n     * The widget type identifier\n     */\n    type: string;\n    /**\n     * The renderer: can be a function returning HTML, an Angular Component class, or a TemplateRef\n     */\n    renderer: CustomWidgetRenderer;\n}\n/**\n * Type guard to check if a renderer is a TemplateRef\n */\ndeclare function isTemplateRenderer(renderer: CustomWidgetRenderer): renderer is TemplateRef<WidgetTemplateContext>;\n/**\n * Type guard to check if a renderer is an Angular Component\n *\n * Note: This uses a heuristic check based on the following assumptions:\n * 1. Components are constructor functions\n * 2. Components have a prototype with a constructor property\n * 3. Components typically use dependency injection (no required constructor params)\n *\n * Limitation: This may not detect components with required constructor parameters.\n * For edge cases, explicitly check your component's constructor signature.\n *\n * Alternative: You can always register a wrapper component that has no required params.\n */\ndeclare function isComponentRenderer(renderer: CustomWidgetRenderer): renderer is Type<CustomWidgetComponent>;\n/**\n * Type guard to check if a renderer is an HTML function\n *\n * Note: This should be checked AFTER checking for component and template renderers\n * since components are also functions but with additional properties.\n */\ndeclare function isHtmlRenderer(renderer: CustomWidgetRenderer): renderer is CustomWidgetHtmlRenderer;","originalLength":2737,"removedExports":[],"renderedExports":["WidgetTemplateContext","CustomWidgetComponent","CustomWidgetHtmlRenderer","CustomWidgetRenderer","CustomWidgetRendererConfig","isTemplateRenderer","isComponentRenderer","isHtmlRenderer"],"renderedLength":2581},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/widget-registry.service.d.ts":{"code":"/**\n * Service for registering custom widget factories and renderers\n *\n * This service provides a centralized way to register custom widget types\n * that extend the base widget functionality, including support for\n * Angular components and templates as custom renderers.\n *\n * @example\n * ```typescript\n * constructor(private widgetRegistry: WidgetRegistryService) {\n *   // Register a widget factory\n *   this.widgetRegistry.registerFactory('myWidget', (obj) => {\n *     if (obj.type === 'myWidget') {\n *       return new MyCustomWidget(obj.label, obj.action);\n *     }\n *     return null;\n *   });\n *\n *   // Register a component-based renderer\n *   this.widgetRegistry.registerRenderer('myWidget', MyWidgetComponent);\n * }\n * ```\n */\ndeclare class WidgetRegistryService {\n    private readonly customRenderers;\n    /**\n     * Register a custom widget factory function\n     *\n     * @param type - The widget type identifier\n     * @param factory - Factory function that creates widget instances from plain objects\n     */\n    registerFactory(type: string, factory: (obj: unknown) => ChatWidget | null): void;\n    /**\n     * Register a widget class with automatic factory creation\n     *\n     * @param type - The widget type identifier\n     * @param ctor - Widget class constructor\n     */\n    registerClass(type: string, ctor: any): void;\n    /**\n     * Get a factory for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The factory function if registered, undefined otherwise\n     */\n    getFactory(type: string): ((obj: any) => ChatWidget | null) | undefined;\n    /**\n     * Register a custom renderer for a specific widget type\n     *\n     * The renderer can be:\n     * - A function that returns HTML string\n     * - An Angular Component class\n     * - An Angular TemplateRef\n     *\n     * @param type - The widget type identifier\n     * @param renderer - The custom renderer (function, Component, or TemplateRef)\n     *\n     * @example\n     * ```typescript\n     * // HTML function renderer\n     * widgetRegistry.registerRenderer('weather', (widget) => `<div>${widget.label}</div>`);\n     *\n     * // Component renderer\n     * widgetRegistry.registerRenderer('weather', WeatherWidgetComponent);\n     *\n     * // Template renderer (from @ViewChild or elsewhere)\n     * widgetRegistry.registerRenderer('weather', this.weatherTemplate);\n     * ```\n     */\n    registerRenderer(type: string, renderer: CustomWidgetRenderer): void;\n    /**\n     * Get a custom renderer for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The custom renderer if registered, undefined otherwise\n     */\n    getRenderer(type: string): CustomWidgetRenderer | undefined;\n    /**\n     * Check if a custom renderer is registered for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a custom renderer is registered, false otherwise\n     */\n    hasRenderer(type: string): boolean;\n    /**\n     * Unregister a custom renderer for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a renderer was removed, false if none was registered\n     */\n    unregisterRenderer(type: string): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetRegistryService, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<WidgetRegistryService>;\n}","originalLength":3545,"removedExports":[],"renderedExports":["WidgetRegistryService"],"renderedLength":3381},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/widget-di.tokens.d.ts":{"code":"/**\n * Injection token for WidgetEventManager factory\n *\n * Use this token to inject a factory function that creates WidgetEventManager instances.\n * The factory accepts an optional action handler to configure the manager.\n *\n * @example\n * ```typescript\n * constructor(@Inject(WIDGET_EVENT_MANAGER_FACTORY) private eventManagerFactory: WidgetEventManagerFactory) {\n *   const actionHandler = { handle: async (action, payload) => { ... } };\n *   this.eventManager = this.eventManagerFactory(actionHandler);\n * }\n * ```\n */\ntype WidgetEventManagerFactory = (actionHandler?: IWidgetActionHandler) => WidgetEventManager;\ndeclare const WIDGET_EVENT_MANAGER_FACTORY: InjectionToken<WidgetEventManagerFactory>;\n/**\n * Injection token for SsrWidgetRenderer\n *\n * Use this token to inject a SsrWidgetRenderer instance in your components.\n * By default, WidgetRendererComponent provides this token with a factory that creates\n * a new instance for each component.\n *\n * @example\n * ```typescript\n * constructor(@Inject(SSR_WIDGET_RENDERER) private renderer: SsrWidgetRenderer) {}\n * ```\n */\ndeclare const SSR_WIDGET_RENDERER: InjectionToken<SsrWidgetRenderer>;\n/**\n * Factory function for creating WidgetEventManager instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization.\n *\n * @returns A factory function that creates WidgetEventManager instances\n */\ndeclare function widgetEventManagerFactoryProvider(): WidgetEventManagerFactory;\n/**\n * Factory function for creating SsrWidgetRenderer instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization\n * or custom rendering options.\n *\n * @returns A new SsrWidgetRenderer instance\n */\ndeclare function ssrWidgetRendererFactory(): SsrWidgetRenderer;","originalLength":2103,"removedExports":[],"renderedExports":["WidgetEventManagerFactory","WIDGET_EVENT_MANAGER_FACTORY","SSR_WIDGET_RENDERER","widgetEventManagerFactoryProvider","ssrWidgetRendererFactory"],"renderedLength":1922},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/widget-renderer.component.d.ts":{"code":"/**\n * Angular component for rendering chat widgets\n *\n * This component handles rendering of chat widgets using the BbQ ChatWidgets library.\n * It manages widget lifecycle, event handling, and cleanup.\n *\n * Supports three types of custom widget renderers:\n * 1. HTML function renderers (return HTML strings)\n * 2. Angular Component renderers (render as dynamic components)\n * 3. Angular TemplateRef renderers (render as embedded views)\n *\n * @example\n * ```typescript\n * <bbq-widget-renderer\n *   [widgets]=\"messageWidgets\"\n *   (widgetAction)=\"handleWidgetAction($event)\">\n * </bbq-widget-renderer>\n * ```\n */\ndeclare class WidgetRendererComponent implements OnInit, AfterViewInit, OnDestroy, OnChanges {\n    protected renderer: SsrWidgetRenderer;\n    protected eventManagerFactory: WidgetEventManagerFactory;\n    protected widgetRegistry: WidgetRegistryService;\n    protected injector: Injector;\n    protected environmentInjector: EnvironmentInjector;\n    /**\n     * Array of widgets to render\n     */\n    widgets: ChatWidget[] | null | undefined;\n    /**\n     * Emits when a widget action is triggered\n     */\n    widgetAction: EventEmitter<{\n        actionName: string;\n        payload: unknown;\n    }>;\n    containerRef: ElementRef<HTMLDivElement>;\n    protected widgetItems: Array<{\n        index: number;\n        widget: ChatWidget;\n        isHtml: boolean;\n        html?: string;\n    }>;\n    protected eventManager?: WidgetEventManager;\n    protected isViewInitialized: boolean;\n    protected dynamicComponents: Array<ComponentRef<any>>;\n    protected dynamicViews: Array<EmbeddedViewRef<WidgetTemplateContext>>;\n    constructor(renderer: SsrWidgetRenderer, eventManagerFactory: WidgetEventManagerFactory, widgetRegistry: WidgetRegistryService, injector: Injector, environmentInjector: EnvironmentInjector);\n    ngOnInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Base implementation for updating the rendered HTML for the current widgets.\n     *\n     * Subclasses may override this method to customize how widgets are rendered\n     * (for example, to inject additional markup or perform preprocessing).\n     *\n     * Since this is the base implementation, overriding implementations are not\n     * required to call `super.updateWidgetHtml()`.\n     */\n    protected updateWidgetHtml(): void;\n    /**\n     * Render dynamic components and templates for custom widgets\n     */\n    protected renderDynamicWidgets(): void;\n    /**\n     * Render an Angular component for a custom widget\n     *\n     * Note: This method safely assigns properties to component instances\n     * by checking for property existence at runtime. This approach is necessary\n     * because we cannot statically verify that all components implement\n     * the CustomWidgetComponent interface.\n     */\n    protected renderComponent(componentType: any, widget: ChatWidget, targetElement: HTMLElement): void;\n    /**\n     * Render an Angular template for a custom widget\n     */\n    protected renderTemplate(templateRef: TemplateRef<WidgetTemplateContext>, widget: ChatWidget, targetElement: HTMLElement): void;\n    /**\n     * Cleanup dynamic components and views\n     */\n    protected cleanupDynamicWidgets(): void;\n    private setupEventHandlers;\n    handleClick(event: MouseEvent): void;\n    /**\n     * Cleanup all resources including event listeners.\n     */\n    private cleanup;\n    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetRendererComponent, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetRendererComponent, \"bbq-widget-renderer\", never, { \"widgets\": { \"alias\": \"widgets\"; \"required\": false; }; }, { \"widgetAction\": \"widgetAction\"; }, never, never, true, never>;\n}","originalLength":4266,"removedExports":[],"renderedExports":["WidgetRendererComponent"],"renderedLength":3738},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-typings/public_api.d.ts":{"code":"/**\n * @bbq-chat/widgets-angular\n *\n * Angular components and services for BbQ ChatWidgets\n *\n * This package provides Angular-native components and services that wrap\n * the core @bbq-chat/widgets library, making it easy to integrate chat\n * widgets into Angular applications.\n *\n * @packageDocumentation\n */\n\ndeclare const VERSION = \"1.0.2\";","originalLength":1422,"removedExports":[],"renderedExports":["VERSION"],"renderedLength":343},"C:\\Users\\jm\\source\\repos\\BbQ.ChatWidgets\\js-angular\\dist\\tmp-typings\\index.d.ts":{"code":null,"originalLength":130,"removedExports":[],"renderedExports":[],"renderedLength":0}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { Type, TemplateRef, InjectionToken, OnInit, AfterViewInit, OnDestroy, OnChanges, Injector, EnvironmentInjector, EventEmitter, ElementRef, ComponentRef, EmbeddedViewRef, SimpleChanges } from '@angular/core';\nimport { ChatWidget, IWidgetActionHandler, WidgetEventManager, SsrWidgetRenderer } from '@bbq-chat/widgets';\nexport { ButtonWidget, CardWidget, ChatWidget, DatePickerWidget, DropdownWidget, FileUploadWidget, FormWidget, ImageCollectionWidget, ImageWidget, InputWidget, MultiSelectWidget, ProgressBarWidget, SliderWidget, SsrWidgetRenderer, TextAreaWidget, ThemeSwitcherWidget, ToggleWidget, WidgetEventManager, customWidgetRegistry } from '@bbq-chat/widgets';\n\n/**\n * Context provided to template-based custom widget renderers\n */\ninterface WidgetTemplateContext {\n    /**\n     * The widget instance being rendered\n     */\n    $implicit: ChatWidget;\n    /**\n     * The widget instance (alternative access)\n     */\n    widget: ChatWidget;\n    /**\n     * Emit a widget action\n     */\n    emitAction: (actionName: string, payload: unknown) => void;\n}\n/**\n * Interface for component-based custom widget renderers\n */\ninterface CustomWidgetComponent {\n    /**\n     * The widget instance to render\n     */\n    widget: ChatWidget;\n    /**\n     * Event emitter for widget actions (optional, will be set by the renderer)\n     */\n    widgetAction?: (actionName: string, payload: unknown) => void;\n}\n/**\n * Type for custom widget renderer functions that return HTML strings\n */\ntype CustomWidgetHtmlRenderer = (widget: ChatWidget) => string;\n/**\n * Type for custom widget renderer configurations\n */\ntype CustomWidgetRenderer = CustomWidgetHtmlRenderer | Type<CustomWidgetComponent> | TemplateRef<WidgetTemplateContext>;\n/**\n * Configuration for registering a custom widget renderer\n */\ninterface CustomWidgetRendererConfig {\n    /**\n     * The widget type identifier\n     */\n    type: string;\n    /**\n     * The renderer: can be a function returning HTML, an Angular Component class, or a TemplateRef\n     */\n    renderer: CustomWidgetRenderer;\n}\n/**\n * Type guard to check if a renderer is a TemplateRef\n */\ndeclare function isTemplateRenderer(renderer: CustomWidgetRenderer): renderer is TemplateRef<WidgetTemplateContext>;\n/**\n * Type guard to check if a renderer is an Angular Component\n *\n * Note: This uses a heuristic check based on the following assumptions:\n * 1. Components are constructor functions\n * 2. Components have a prototype with a constructor property\n * 3. Components typically use dependency injection (no required constructor params)\n *\n * Limitation: This may not detect components with required constructor parameters.\n * For edge cases, explicitly check your component's constructor signature.\n *\n * Alternative: You can always register a wrapper component that has no required params.\n */\ndeclare function isComponentRenderer(renderer: CustomWidgetRenderer): renderer is Type<CustomWidgetComponent>;\n/**\n * Type guard to check if a renderer is an HTML function\n *\n * Note: This should be checked AFTER checking for component and template renderers\n * since components are also functions but with additional properties.\n */\ndeclare function isHtmlRenderer(renderer: CustomWidgetRenderer): renderer is CustomWidgetHtmlRenderer;\n\n/**\n * Service for registering custom widget factories and renderers\n *\n * This service provides a centralized way to register custom widget types\n * that extend the base widget functionality, including support for\n * Angular components and templates as custom renderers.\n *\n * @example\n * ```typescript\n * constructor(private widgetRegistry: WidgetRegistryService) {\n *   // Register a widget factory\n *   this.widgetRegistry.registerFactory('myWidget', (obj) => {\n *     if (obj.type === 'myWidget') {\n *       return new MyCustomWidget(obj.label, obj.action);\n *     }\n *     return null;\n *   });\n *\n *   // Register a component-based renderer\n *   this.widgetRegistry.registerRenderer('myWidget', MyWidgetComponent);\n * }\n * ```\n */\ndeclare class WidgetRegistryService {\n    private readonly customRenderers;\n    /**\n     * Register a custom widget factory function\n     *\n     * @param type - The widget type identifier\n     * @param factory - Factory function that creates widget instances from plain objects\n     */\n    registerFactory(type: string, factory: (obj: unknown) => ChatWidget | null): void;\n    /**\n     * Register a widget class with automatic factory creation\n     *\n     * @param type - The widget type identifier\n     * @param ctor - Widget class constructor\n     */\n    registerClass(type: string, ctor: any): void;\n    /**\n     * Get a factory for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The factory function if registered, undefined otherwise\n     */\n    getFactory(type: string): ((obj: any) => ChatWidget | null) | undefined;\n    /**\n     * Register a custom renderer for a specific widget type\n     *\n     * The renderer can be:\n     * - A function that returns HTML string\n     * - An Angular Component class\n     * - An Angular TemplateRef\n     *\n     * @param type - The widget type identifier\n     * @param renderer - The custom renderer (function, Component, or TemplateRef)\n     *\n     * @example\n     * ```typescript\n     * // HTML function renderer\n     * widgetRegistry.registerRenderer('weather', (widget) => `<div>${widget.label}</div>`);\n     *\n     * // Component renderer\n     * widgetRegistry.registerRenderer('weather', WeatherWidgetComponent);\n     *\n     * // Template renderer (from @ViewChild or elsewhere)\n     * widgetRegistry.registerRenderer('weather', this.weatherTemplate);\n     * ```\n     */\n    registerRenderer(type: string, renderer: CustomWidgetRenderer): void;\n    /**\n     * Get a custom renderer for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The custom renderer if registered, undefined otherwise\n     */\n    getRenderer(type: string): CustomWidgetRenderer | undefined;\n    /**\n     * Check if a custom renderer is registered for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a custom renderer is registered, false otherwise\n     */\n    hasRenderer(type: string): boolean;\n    /**\n     * Unregister a custom renderer for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a renderer was removed, false if none was registered\n     */\n    unregisterRenderer(type: string): boolean;\n    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetRegistryService, never>;\n    static ɵprov: i0.ɵɵInjectableDeclaration<WidgetRegistryService>;\n}\n\n/**\n * Injection token for WidgetEventManager factory\n *\n * Use this token to inject a factory function that creates WidgetEventManager instances.\n * The factory accepts an optional action handler to configure the manager.\n *\n * @example\n * ```typescript\n * constructor(@Inject(WIDGET_EVENT_MANAGER_FACTORY) private eventManagerFactory: WidgetEventManagerFactory) {\n *   const actionHandler = { handle: async (action, payload) => { ... } };\n *   this.eventManager = this.eventManagerFactory(actionHandler);\n * }\n * ```\n */\ntype WidgetEventManagerFactory = (actionHandler?: IWidgetActionHandler) => WidgetEventManager;\ndeclare const WIDGET_EVENT_MANAGER_FACTORY: InjectionToken<WidgetEventManagerFactory>;\n/**\n * Injection token for SsrWidgetRenderer\n *\n * Use this token to inject a SsrWidgetRenderer instance in your components.\n * By default, WidgetRendererComponent provides this token with a factory that creates\n * a new instance for each component.\n *\n * @example\n * ```typescript\n * constructor(@Inject(SSR_WIDGET_RENDERER) private renderer: SsrWidgetRenderer) {}\n * ```\n */\ndeclare const SSR_WIDGET_RENDERER: InjectionToken<SsrWidgetRenderer>;\n/**\n * Factory function for creating WidgetEventManager instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization.\n *\n * @returns A factory function that creates WidgetEventManager instances\n */\ndeclare function widgetEventManagerFactoryProvider(): WidgetEventManagerFactory;\n/**\n * Factory function for creating SsrWidgetRenderer instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization\n * or custom rendering options.\n *\n * @returns A new SsrWidgetRenderer instance\n */\ndeclare function ssrWidgetRendererFactory(): SsrWidgetRenderer;\n\n/**\n * Angular component for rendering chat widgets\n *\n * This component handles rendering of chat widgets using the BbQ ChatWidgets library.\n * It manages widget lifecycle, event handling, and cleanup.\n *\n * Supports three types of custom widget renderers:\n * 1. HTML function renderers (return HTML strings)\n * 2. Angular Component renderers (render as dynamic components)\n * 3. Angular TemplateRef renderers (render as embedded views)\n *\n * @example\n * ```typescript\n * <bbq-widget-renderer\n *   [widgets]=\"messageWidgets\"\n *   (widgetAction)=\"handleWidgetAction($event)\">\n * </bbq-widget-renderer>\n * ```\n */\ndeclare class WidgetRendererComponent implements OnInit, AfterViewInit, OnDestroy, OnChanges {\n    protected renderer: SsrWidgetRenderer;\n    protected eventManagerFactory: WidgetEventManagerFactory;\n    protected widgetRegistry: WidgetRegistryService;\n    protected injector: Injector;\n    protected environmentInjector: EnvironmentInjector;\n    /**\n     * Array of widgets to render\n     */\n    widgets: ChatWidget[] | null | undefined;\n    /**\n     * Emits when a widget action is triggered\n     */\n    widgetAction: EventEmitter<{\n        actionName: string;\n        payload: unknown;\n    }>;\n    containerRef: ElementRef<HTMLDivElement>;\n    protected widgetItems: Array<{\n        index: number;\n        widget: ChatWidget;\n        isHtml: boolean;\n        html?: string;\n    }>;\n    protected eventManager?: WidgetEventManager;\n    protected isViewInitialized: boolean;\n    protected dynamicComponents: Array<ComponentRef<any>>;\n    protected dynamicViews: Array<EmbeddedViewRef<WidgetTemplateContext>>;\n    constructor(renderer: SsrWidgetRenderer, eventManagerFactory: WidgetEventManagerFactory, widgetRegistry: WidgetRegistryService, injector: Injector, environmentInjector: EnvironmentInjector);\n    ngOnInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Base implementation for updating the rendered HTML for the current widgets.\n     *\n     * Subclasses may override this method to customize how widgets are rendered\n     * (for example, to inject additional markup or perform preprocessing).\n     *\n     * Since this is the base implementation, overriding implementations are not\n     * required to call `super.updateWidgetHtml()`.\n     */\n    protected updateWidgetHtml(): void;\n    /**\n     * Render dynamic components and templates for custom widgets\n     */\n    protected renderDynamicWidgets(): void;\n    /**\n     * Render an Angular component for a custom widget\n     *\n     * Note: This method safely assigns properties to component instances\n     * by checking for property existence at runtime. This approach is necessary\n     * because we cannot statically verify that all components implement\n     * the CustomWidgetComponent interface.\n     */\n    protected renderComponent(componentType: any, widget: ChatWidget, targetElement: HTMLElement): void;\n    /**\n     * Render an Angular template for a custom widget\n     */\n    protected renderTemplate(templateRef: TemplateRef<WidgetTemplateContext>, widget: ChatWidget, targetElement: HTMLElement): void;\n    /**\n     * Cleanup dynamic components and views\n     */\n    protected cleanupDynamicWidgets(): void;\n    private setupEventHandlers;\n    handleClick(event: MouseEvent): void;\n    /**\n     * Cleanup all resources including event listeners.\n     */\n    private cleanup;\n    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetRendererComponent, never>;\n    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetRendererComponent, \"bbq-widget-renderer\", never, { \"widgets\": { \"alias\": \"widgets\"; \"required\": false; }; }, { \"widgetAction\": \"widgetAction\"; }, never, never, true, never>;\n}\n\n/**\n * @bbq-chat/widgets-angular\n *\n * Angular components and services for BbQ ChatWidgets\n *\n * This package provides Angular-native components and services that wrap\n * the core @bbq-chat/widgets library, making it easy to integrate chat\n * widgets into Angular applications.\n *\n * @packageDocumentation\n */\n\ndeclare const VERSION = \"1.0.2\";\n\nexport { SSR_WIDGET_RENDERER, VERSION, WIDGET_EVENT_MANAGER_FACTORY, WidgetRegistryService, WidgetRendererComponent, isComponentRenderer, isHtmlRenderer, isTemplateRenderer, ssrWidgetRendererFactory, widgetEventManagerFactoryProvider };\nexport type { CustomWidgetComponent, CustomWidgetHtmlRenderer, CustomWidgetRenderer, CustomWidgetRendererConfig, WidgetEventManagerFactory, WidgetTemplateContext };\n","map":null,"preliminaryFileName":"index.d.ts","sourcemapFileName":null}],"fesm2022":[{"exports":["ChatWidget","SSR_WIDGET_RENDERER","SsrWidgetRenderer","VERSION","WIDGET_EVENT_MANAGER_FACTORY","WidgetEventManager","WidgetRegistryService","WidgetRendererComponent","customWidgetRegistry","isComponentRenderer","isHtmlRenderer","isTemplateRenderer","ssrWidgetRendererFactory","widgetEventManagerFactoryProvider"],"facadeModuleId":"C:\\Users\\jm\\source\\repos\\BbQ.ChatWidgets\\js-angular\\dist\\tmp-esm2022\\index.js","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/custom-widget-renderer.types.js","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/widget-di.tokens.js","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/widget-registry.service.js","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/widget-renderer.component.js","C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/public_api.js","C:\\Users\\jm\\source\\repos\\BbQ.ChatWidgets\\js-angular\\dist\\tmp-esm2022\\index.js"],"name":"index","type":"chunk","dynamicImports":[],"fileName":"index.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["InjectionToken","*","Injectable","EventEmitter","createComponent","ViewChild","Output","Input","Inject","Component"],"@angular/common":["CommonModule"],"@bbq-chat/widgets":["WidgetEventManager","SsrWidgetRenderer","customWidgetRegistry","*","ChatWidget"]},"imports":["@angular/core","@angular/common","@bbq-chat/widgets"],"modules":{"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/custom-widget-renderer.types.js":{"code":"/**\n * Type guard to check if a renderer is a TemplateRef\n */\nfunction isTemplateRenderer(renderer) {\n    return (renderer !== null &&\n        typeof renderer === 'object' &&\n        'createEmbeddedView' in renderer);\n}\n/**\n * Type guard to check if a renderer is an Angular Component\n *\n * Note: This uses a heuristic check based on the following assumptions:\n * 1. Components are constructor functions\n * 2. Components have a prototype with a constructor property\n * 3. Components typically use dependency injection (no required constructor params)\n *\n * Limitation: This may not detect components with required constructor parameters.\n * For edge cases, explicitly check your component's constructor signature.\n *\n * Alternative: You can always register a wrapper component that has no required params.\n */\nfunction isComponentRenderer(renderer) {\n    // Check if it's a function (constructor) but not a regular function renderer\n    if (typeof renderer !== 'function') {\n        return false;\n    }\n    // Check for Angular component characteristics\n    // Components typically have prototype with constructor property\n    return (renderer.prototype !== undefined &&\n        renderer.prototype.constructor === renderer &&\n        renderer.length === 0 // Constructor with no required params (Angular DI)\n    );\n}\n/**\n * Type guard to check if a renderer is an HTML function\n *\n * Note: This should be checked AFTER checking for component and template renderers\n * since components are also functions but with additional properties.\n */\nfunction isHtmlRenderer(renderer) {\n    return typeof renderer === 'function';\n}","originalLength":1698,"removedExports":[],"renderedExports":["isTemplateRenderer","isComponentRenderer","isHtmlRenderer"],"renderedLength":1620},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/widget-di.tokens.js":{"code":"const WIDGET_EVENT_MANAGER_FACTORY = new InjectionToken('WIDGET_EVENT_MANAGER_FACTORY');\n/**\n * Injection token for SsrWidgetRenderer\n *\n * Use this token to inject a SsrWidgetRenderer instance in your components.\n * By default, WidgetRendererComponent provides this token with a factory that creates\n * a new instance for each component.\n *\n * @example\n * ```typescript\n * constructor(@Inject(SSR_WIDGET_RENDERER) private renderer: SsrWidgetRenderer) {}\n * ```\n */\nconst SSR_WIDGET_RENDERER = new InjectionToken('SSR_WIDGET_RENDERER');\n/**\n * Factory function for creating WidgetEventManager instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization.\n *\n * @returns A factory function that creates WidgetEventManager instances\n */\nfunction widgetEventManagerFactoryProvider() {\n    return (actionHandler) => new WidgetEventManager(actionHandler);\n}\n/**\n * Factory function for creating SsrWidgetRenderer instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization\n * or custom rendering options.\n *\n * @returns A new SsrWidgetRenderer instance\n */\nfunction ssrWidgetRendererFactory() {\n    return new SsrWidgetRenderer();\n}","originalLength":1552,"removedExports":[],"renderedExports":["WIDGET_EVENT_MANAGER_FACTORY","SSR_WIDGET_RENDERER","widgetEventManagerFactoryProvider","ssrWidgetRendererFactory"],"renderedLength":1356},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/widget-registry.service.js":{"code":"/**\n * Service for registering custom widget factories and renderers\n *\n * This service provides a centralized way to register custom widget types\n * that extend the base widget functionality, including support for\n * Angular components and templates as custom renderers.\n *\n * @example\n * ```typescript\n * constructor(private widgetRegistry: WidgetRegistryService) {\n *   // Register a widget factory\n *   this.widgetRegistry.registerFactory('myWidget', (obj) => {\n *     if (obj.type === 'myWidget') {\n *       return new MyCustomWidget(obj.label, obj.action);\n *     }\n *     return null;\n *   });\n *\n *   // Register a component-based renderer\n *   this.widgetRegistry.registerRenderer('myWidget', MyWidgetComponent);\n * }\n * ```\n */\nclass WidgetRegistryService {\n    customRenderers = new Map();\n    /**\n     * Register a custom widget factory function\n     *\n     * @param type - The widget type identifier\n     * @param factory - Factory function that creates widget instances from plain objects\n     */\n    registerFactory(type, factory) {\n        customWidgetRegistry.registerFactory(type, factory);\n    }\n    /**\n     * Register a widget class with automatic factory creation\n     *\n     * @param type - The widget type identifier\n     * @param ctor - Widget class constructor\n     */\n    registerClass(type, ctor) {\n        customWidgetRegistry.registerClass(type, ctor);\n    }\n    /**\n     * Get a factory for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The factory function if registered, undefined otherwise\n     */\n    getFactory(type) {\n        return customWidgetRegistry.getFactory(type);\n    }\n    /**\n     * Register a custom renderer for a specific widget type\n     *\n     * The renderer can be:\n     * - A function that returns HTML string\n     * - An Angular Component class\n     * - An Angular TemplateRef\n     *\n     * @param type - The widget type identifier\n     * @param renderer - The custom renderer (function, Component, or TemplateRef)\n     *\n     * @example\n     * ```typescript\n     * // HTML function renderer\n     * widgetRegistry.registerRenderer('weather', (widget) => `<div>${widget.label}</div>`);\n     *\n     * // Component renderer\n     * widgetRegistry.registerRenderer('weather', WeatherWidgetComponent);\n     *\n     * // Template renderer (from @ViewChild or elsewhere)\n     * widgetRegistry.registerRenderer('weather', this.weatherTemplate);\n     * ```\n     */\n    registerRenderer(type, renderer) {\n        if (!type || typeof type !== 'string') {\n            throw new Error('type must be a non-empty string');\n        }\n        if (!renderer) {\n            throw new Error('renderer is required');\n        }\n        this.customRenderers.set(type, renderer);\n    }\n    /**\n     * Get a custom renderer for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The custom renderer if registered, undefined otherwise\n     */\n    getRenderer(type) {\n        return this.customRenderers.get(type);\n    }\n    /**\n     * Check if a custom renderer is registered for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a custom renderer is registered, false otherwise\n     */\n    hasRenderer(type) {\n        return this.customRenderers.has(type);\n    }\n    /**\n     * Unregister a custom renderer for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a renderer was removed, false if none was registered\n     */\n    unregisterRenderer(type) {\n        return this.customRenderers.delete(type);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRegistryService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRegistryService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRegistryService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });","originalLength":4398,"removedExports":[],"renderedExports":["WidgetRegistryService"],"renderedLength":4200},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/widget-renderer.component.js":{"code":"/**\n * Angular component for rendering chat widgets\n *\n * This component handles rendering of chat widgets using the BbQ ChatWidgets library.\n * It manages widget lifecycle, event handling, and cleanup.\n *\n * Supports three types of custom widget renderers:\n * 1. HTML function renderers (return HTML strings)\n * 2. Angular Component renderers (render as dynamic components)\n * 3. Angular TemplateRef renderers (render as embedded views)\n *\n * @example\n * ```typescript\n * <bbq-widget-renderer\n *   [widgets]=\"messageWidgets\"\n *   (widgetAction)=\"handleWidgetAction($event)\">\n * </bbq-widget-renderer>\n * ```\n */\nclass WidgetRendererComponent {\n    renderer;\n    eventManagerFactory;\n    widgetRegistry;\n    injector;\n    environmentInjector;\n    /**\n     * Array of widgets to render\n     */\n    widgets;\n    /**\n     * Emits when a widget action is triggered\n     */\n    widgetAction = new EventEmitter();\n    containerRef;\n    widgetItems = [];\n    eventManager;\n    isViewInitialized = false;\n    dynamicComponents = [];\n    dynamicViews = [];\n    constructor(renderer, eventManagerFactory, widgetRegistry, injector, environmentInjector) {\n        this.renderer = renderer;\n        this.eventManagerFactory = eventManagerFactory;\n        this.widgetRegistry = widgetRegistry;\n        this.injector = injector;\n        this.environmentInjector = environmentInjector;\n    }\n    ngOnInit() {\n        // this.updateWidgetHtml();\n    }\n    ngOnChanges(changes) {\n        if (changes['widgets']) {\n            this.updateWidgetHtml();\n        }\n    }\n    ngAfterViewInit() {\n        this.updateWidgetHtml();\n        this.isViewInitialized = true;\n        this.setupEventHandlers();\n        // Render dynamic components/templates after view init\n        this.renderDynamicWidgets();\n    }\n    ngOnDestroy() {\n        this.cleanup();\n    }\n    /**\n     * Base implementation for updating the rendered HTML for the current widgets.\n     *\n     * Subclasses may override this method to customize how widgets are rendered\n     * (for example, to inject additional markup or perform preprocessing).\n     *\n     * Since this is the base implementation, overriding implementations are not\n     * required to call `super.updateWidgetHtml()`.\n     */\n    updateWidgetHtml() {\n        if (!this.widgets || this.widgets.length === 0) {\n            this.widgetItems = [];\n            return;\n        }\n        this.widgetItems = this.widgets.map((widget, index) => {\n            const customRenderer = this.widgetRegistry.getRenderer(widget.type);\n            // Check template renderer first (most specific)\n            if (customRenderer && isTemplateRenderer(customRenderer)) {\n                return {\n                    index,\n                    widget,\n                    isHtml: false,\n                };\n            }\n            // Check component renderer second\n            if (customRenderer && isComponentRenderer(customRenderer)) {\n                return {\n                    index,\n                    widget,\n                    isHtml: false,\n                };\n            }\n            // Check HTML function renderer last (most general, matches any function)\n            if (customRenderer && isHtmlRenderer(customRenderer)) {\n                return {\n                    index,\n                    widget,\n                    isHtml: true,\n                    html: customRenderer(widget),\n                };\n            }\n            // Default: render using the BbQ library renderer\n            return {\n                index,\n                widget,\n                isHtml: true,\n                html: this.renderer.renderWidget(widget),\n            };\n        });\n        // After view updates, reinitialize widgets only if view is already initialized\n        if (this.isViewInitialized) {\n            setTimeout(() => {\n                this.setupEventHandlers();\n                this.renderDynamicWidgets();\n            }, 0);\n        }\n    }\n    /**\n     * Render dynamic components and templates for custom widgets\n     */\n    renderDynamicWidgets() {\n        if (!this.containerRef?.nativeElement)\n            return;\n        // Use microtask to ensure Angular has completed change detection\n        Promise.resolve().then(() => {\n            if (!this.containerRef?.nativeElement)\n                return;\n            // Clean up existing dynamic components and views\n            this.cleanupDynamicWidgets();\n            const container = this.containerRef.nativeElement;\n            // Query all widget divs without the data-rendered filter\n            const dynamicWidgetDivs = Array.from(container.querySelectorAll('.bbq-widget'));\n            let dynamicIndex = 0;\n            this.widgetItems.forEach((item) => {\n                if (!item.isHtml) {\n                    const customRenderer = this.widgetRegistry.getRenderer(item.widget.type);\n                    if (!customRenderer)\n                        return;\n                    const targetDiv = dynamicWidgetDivs[dynamicIndex];\n                    if (!targetDiv)\n                        return;\n                    // Clear the div content before rendering\n                    targetDiv.innerHTML = '';\n                    if (isComponentRenderer(customRenderer)) {\n                        this.renderComponent(customRenderer, item.widget, targetDiv);\n                    }\n                    else if (isTemplateRenderer(customRenderer)) {\n                        this.renderTemplate(customRenderer, item.widget, targetDiv);\n                    }\n                    dynamicIndex++;\n                }\n            });\n        });\n    }\n    /**\n     * Render an Angular component for a custom widget\n     *\n     * Note: This method safely assigns properties to component instances\n     * by checking for property existence at runtime. This approach is necessary\n     * because we cannot statically verify that all components implement\n     * the CustomWidgetComponent interface.\n     */\n    renderComponent(componentType, widget, targetElement) {\n        // Create the component using Angular's createComponent API\n        const componentRef = createComponent(componentType, {\n            environmentInjector: this.environmentInjector,\n            elementInjector: this.injector,\n        });\n        // Safely set component inputs if they exist\n        const instance = componentRef.instance;\n        if (instance && typeof instance === 'object') {\n            // Set widget property if it exists in the prototype chain\n            if ('widget' in instance) {\n                instance.widget = widget;\n            }\n            // Set widgetAction callback if it exists in the prototype chain\n            if ('widgetAction' in instance) {\n                instance.widgetAction = (actionName, payload) => {\n                    this.widgetAction.emit({ actionName, payload });\n                };\n            }\n        }\n        // Attach the component's host view to the target element\n        targetElement.appendChild(componentRef.location.nativeElement);\n        // Store reference for cleanup\n        this.dynamicComponents.push(componentRef);\n        // Trigger change detection (use optional chaining for safety)\n        componentRef.changeDetectorRef?.detectChanges();\n    }\n    /**\n     * Render an Angular template for a custom widget\n     */\n    renderTemplate(templateRef, widget, targetElement) {\n        const context = {\n            $implicit: widget,\n            widget: widget,\n            emitAction: (actionName, payload) => {\n                this.widgetAction.emit({ actionName, payload });\n            },\n        };\n        const viewRef = templateRef.createEmbeddedView(context);\n        // Attach the view's DOM nodes to the target element\n        viewRef.rootNodes.forEach((node) => {\n            targetElement.appendChild(node);\n        });\n        // Store reference for cleanup\n        this.dynamicViews.push(viewRef);\n        // Trigger change detection\n        viewRef.detectChanges();\n    }\n    /**\n     * Cleanup dynamic components and views\n     */\n    cleanupDynamicWidgets() {\n        this.dynamicComponents.forEach((componentRef) => {\n            componentRef.destroy();\n        });\n        this.dynamicComponents = [];\n        this.dynamicViews.forEach((viewRef) => {\n            viewRef.destroy();\n        });\n        this.dynamicViews = [];\n    }\n    setupEventHandlers() {\n        if (!this.containerRef?.nativeElement)\n            return;\n        // Cleanup old resources before setting up new ones\n        this.cleanup();\n        const container = this.containerRef.nativeElement;\n        // Create a custom action handler that emits events\n        const actionHandler = {\n            handle: async (action, payload) => {\n                this.widgetAction.emit({ actionName: action, payload });\n            },\n        };\n        // Use the injected factory to create an event manager with the component-specific action handler\n        this.eventManager = this.eventManagerFactory(actionHandler);\n        this.eventManager.attachHandlers(container);\n    }\n    handleClick(event) {\n        const target = event.target;\n        // Only trigger actions on non-form buttons and clickable elements (cards)\n        // Don't trigger on input elements or form buttons (let WidgetEventManager handle those)\n        const button = target.tagName === 'BUTTON' ? target : target.closest('button');\n        if (button && !button.closest('[data-widget-type=\"form\"]')) {\n            const actionName = button.getAttribute('data-action');\n            if (actionName) {\n                try {\n                    const payloadStr = button.getAttribute('data-payload');\n                    const payload = payloadStr ? JSON.parse(payloadStr) : {};\n                    this.widgetAction.emit({ actionName, payload });\n                }\n                catch (err) {\n                    console.error('Failed to parse widget action payload:', err);\n                }\n            }\n        }\n    }\n    /**\n     * Cleanup all resources including event listeners.\n     */\n    cleanup() {\n        // Cleanup dynamic widgets first\n        this.cleanupDynamicWidgets();\n        // Cleanup event manager\n        this.eventManager = undefined;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRendererComponent, deps: [{ token: SSR_WIDGET_RENDERER }, { token: WIDGET_EVENT_MANAGER_FACTORY }, { token: WidgetRegistryService }, { token: i0.Injector }, { token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.0.0\", version: \"21.0.8\", type: WidgetRendererComponent, isStandalone: true, selector: \"bbq-widget-renderer\", inputs: { widgets: \"widgets\" }, outputs: { widgetAction: \"widgetAction\" }, providers: [\n            { provide: WIDGET_EVENT_MANAGER_FACTORY, useFactory: widgetEventManagerFactoryProvider },\n            { provide: SSR_WIDGET_RENDERER, useFactory: ssrWidgetRendererFactory },\n        ], viewQueries: [{ propertyName: \"containerRef\", first: true, predicate: [\"widgetContainer\"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `\r\n    <div #widgetContainer class=\"bbq-widgets-container\" (click)=\"handleClick($event)\">\r\n      @for (item of widgetItems; track item.index) {\r\n        @if (item.isHtml) {\r\n          <div class=\"bbq-widget\" [innerHTML]=\"item.html\"></div>\r\n        } @else {\r\n          <div class=\"bbq-widget\" #dynamicWidget></div>\r\n        }\r\n      }\r\n    </div>\r\n  `, isInline: true, styles: [\".bbq-widgets-container{margin-top:.5rem}.bbq-widget{margin-bottom:.5rem}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRendererComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'bbq-widget-renderer', standalone: true, imports: [CommonModule], providers: [\n                        { provide: WIDGET_EVENT_MANAGER_FACTORY, useFactory: widgetEventManagerFactoryProvider },\n                        { provide: SSR_WIDGET_RENDERER, useFactory: ssrWidgetRendererFactory },\n                    ], template: `\r\n    <div #widgetContainer class=\"bbq-widgets-container\" (click)=\"handleClick($event)\">\r\n      @for (item of widgetItems; track item.index) {\r\n        @if (item.isHtml) {\r\n          <div class=\"bbq-widget\" [innerHTML]=\"item.html\"></div>\r\n        } @else {\r\n          <div class=\"bbq-widget\" #dynamicWidget></div>\r\n        }\r\n      }\r\n    </div>\r\n  `, styles: [\".bbq-widgets-container{margin-top:.5rem}.bbq-widget{margin-bottom:.5rem}\\n\"] }]\n        }], ctorParameters: () => [{ type: i2.SsrWidgetRenderer, decorators: [{\n                    type: Inject,\n                    args: [SSR_WIDGET_RENDERER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [WIDGET_EVENT_MANAGER_FACTORY]\n                }] }, { type: WidgetRegistryService }, { type: i0.Injector }, { type: i0.EnvironmentInjector }], propDecorators: { widgets: [{\n                type: Input\n            }], widgetAction: [{\n                type: Output\n            }], containerRef: [{\n                type: ViewChild,\n                args: ['widgetContainer', { static: false }]\n            }] } });","originalLength":13969,"removedExports":[],"renderedExports":["WidgetRendererComponent"],"renderedLength":13361},"C:/Users/jm/source/repos/BbQ.ChatWidgets/js-angular/dist/tmp-esm2022/public_api.js":{"code":"/**\n * @bbq-chat/widgets-angular\n *\n * Angular components and services for BbQ ChatWidgets\n *\n * This package provides Angular-native components and services that wrap\n * the core @bbq-chat/widgets library, making it easy to integrate chat\n * widgets into Angular applications.\n *\n * @packageDocumentation\n */\n// Export components\n// Version\nconst VERSION = '1.0.2';","originalLength":1093,"removedExports":[],"renderedExports":["VERSION"],"renderedLength":366},"C:\\Users\\jm\\source\\repos\\BbQ.ChatWidgets\\js-angular\\dist\\tmp-esm2022\\index.js":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":111,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, EventEmitter, createComponent, ViewChild, Output, Input, Inject, Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport * as i2 from '@bbq-chat/widgets';\nimport { WidgetEventManager, SsrWidgetRenderer, customWidgetRegistry } from '@bbq-chat/widgets';\nexport { ChatWidget, SsrWidgetRenderer, WidgetEventManager, customWidgetRegistry } from '@bbq-chat/widgets';\n\n/**\n * Type guard to check if a renderer is a TemplateRef\n */\nfunction isTemplateRenderer(renderer) {\n    return (renderer !== null &&\n        typeof renderer === 'object' &&\n        'createEmbeddedView' in renderer);\n}\n/**\n * Type guard to check if a renderer is an Angular Component\n *\n * Note: This uses a heuristic check based on the following assumptions:\n * 1. Components are constructor functions\n * 2. Components have a prototype with a constructor property\n * 3. Components typically use dependency injection (no required constructor params)\n *\n * Limitation: This may not detect components with required constructor parameters.\n * For edge cases, explicitly check your component's constructor signature.\n *\n * Alternative: You can always register a wrapper component that has no required params.\n */\nfunction isComponentRenderer(renderer) {\n    // Check if it's a function (constructor) but not a regular function renderer\n    if (typeof renderer !== 'function') {\n        return false;\n    }\n    // Check for Angular component characteristics\n    // Components typically have prototype with constructor property\n    return (renderer.prototype !== undefined &&\n        renderer.prototype.constructor === renderer &&\n        renderer.length === 0 // Constructor with no required params (Angular DI)\n    );\n}\n/**\n * Type guard to check if a renderer is an HTML function\n *\n * Note: This should be checked AFTER checking for component and template renderers\n * since components are also functions but with additional properties.\n */\nfunction isHtmlRenderer(renderer) {\n    return typeof renderer === 'function';\n}\n\nconst WIDGET_EVENT_MANAGER_FACTORY = new InjectionToken('WIDGET_EVENT_MANAGER_FACTORY');\n/**\n * Injection token for SsrWidgetRenderer\n *\n * Use this token to inject a SsrWidgetRenderer instance in your components.\n * By default, WidgetRendererComponent provides this token with a factory that creates\n * a new instance for each component.\n *\n * @example\n * ```typescript\n * constructor(@Inject(SSR_WIDGET_RENDERER) private renderer: SsrWidgetRenderer) {}\n * ```\n */\nconst SSR_WIDGET_RENDERER = new InjectionToken('SSR_WIDGET_RENDERER');\n/**\n * Factory function for creating WidgetEventManager instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization.\n *\n * @returns A factory function that creates WidgetEventManager instances\n */\nfunction widgetEventManagerFactoryProvider() {\n    return (actionHandler) => new WidgetEventManager(actionHandler);\n}\n/**\n * Factory function for creating SsrWidgetRenderer instances\n *\n * This factory is used by default in WidgetRendererComponent's providers array.\n * You can override this in your own providers if you need custom initialization\n * or custom rendering options.\n *\n * @returns A new SsrWidgetRenderer instance\n */\nfunction ssrWidgetRendererFactory() {\n    return new SsrWidgetRenderer();\n}\n\n/**\n * Service for registering custom widget factories and renderers\n *\n * This service provides a centralized way to register custom widget types\n * that extend the base widget functionality, including support for\n * Angular components and templates as custom renderers.\n *\n * @example\n * ```typescript\n * constructor(private widgetRegistry: WidgetRegistryService) {\n *   // Register a widget factory\n *   this.widgetRegistry.registerFactory('myWidget', (obj) => {\n *     if (obj.type === 'myWidget') {\n *       return new MyCustomWidget(obj.label, obj.action);\n *     }\n *     return null;\n *   });\n *\n *   // Register a component-based renderer\n *   this.widgetRegistry.registerRenderer('myWidget', MyWidgetComponent);\n * }\n * ```\n */\nclass WidgetRegistryService {\n    customRenderers = new Map();\n    /**\n     * Register a custom widget factory function\n     *\n     * @param type - The widget type identifier\n     * @param factory - Factory function that creates widget instances from plain objects\n     */\n    registerFactory(type, factory) {\n        customWidgetRegistry.registerFactory(type, factory);\n    }\n    /**\n     * Register a widget class with automatic factory creation\n     *\n     * @param type - The widget type identifier\n     * @param ctor - Widget class constructor\n     */\n    registerClass(type, ctor) {\n        customWidgetRegistry.registerClass(type, ctor);\n    }\n    /**\n     * Get a factory for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The factory function if registered, undefined otherwise\n     */\n    getFactory(type) {\n        return customWidgetRegistry.getFactory(type);\n    }\n    /**\n     * Register a custom renderer for a specific widget type\n     *\n     * The renderer can be:\n     * - A function that returns HTML string\n     * - An Angular Component class\n     * - An Angular TemplateRef\n     *\n     * @param type - The widget type identifier\n     * @param renderer - The custom renderer (function, Component, or TemplateRef)\n     *\n     * @example\n     * ```typescript\n     * // HTML function renderer\n     * widgetRegistry.registerRenderer('weather', (widget) => `<div>${widget.label}</div>`);\n     *\n     * // Component renderer\n     * widgetRegistry.registerRenderer('weather', WeatherWidgetComponent);\n     *\n     * // Template renderer (from @ViewChild or elsewhere)\n     * widgetRegistry.registerRenderer('weather', this.weatherTemplate);\n     * ```\n     */\n    registerRenderer(type, renderer) {\n        if (!type || typeof type !== 'string') {\n            throw new Error('type must be a non-empty string');\n        }\n        if (!renderer) {\n            throw new Error('renderer is required');\n        }\n        this.customRenderers.set(type, renderer);\n    }\n    /**\n     * Get a custom renderer for a specific widget type\n     *\n     * @param type - The widget type identifier\n     * @returns The custom renderer if registered, undefined otherwise\n     */\n    getRenderer(type) {\n        return this.customRenderers.get(type);\n    }\n    /**\n     * Check if a custom renderer is registered for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a custom renderer is registered, false otherwise\n     */\n    hasRenderer(type) {\n        return this.customRenderers.has(type);\n    }\n    /**\n     * Unregister a custom renderer for a widget type\n     *\n     * @param type - The widget type identifier\n     * @returns True if a renderer was removed, false if none was registered\n     */\n    unregisterRenderer(type) {\n        return this.customRenderers.delete(type);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRegistryService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRegistryService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRegistryService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\n/**\n * Angular component for rendering chat widgets\n *\n * This component handles rendering of chat widgets using the BbQ ChatWidgets library.\n * It manages widget lifecycle, event handling, and cleanup.\n *\n * Supports three types of custom widget renderers:\n * 1. HTML function renderers (return HTML strings)\n * 2. Angular Component renderers (render as dynamic components)\n * 3. Angular TemplateRef renderers (render as embedded views)\n *\n * @example\n * ```typescript\n * <bbq-widget-renderer\n *   [widgets]=\"messageWidgets\"\n *   (widgetAction)=\"handleWidgetAction($event)\">\n * </bbq-widget-renderer>\n * ```\n */\nclass WidgetRendererComponent {\n    renderer;\n    eventManagerFactory;\n    widgetRegistry;\n    injector;\n    environmentInjector;\n    /**\n     * Array of widgets to render\n     */\n    widgets;\n    /**\n     * Emits when a widget action is triggered\n     */\n    widgetAction = new EventEmitter();\n    containerRef;\n    widgetItems = [];\n    eventManager;\n    isViewInitialized = false;\n    dynamicComponents = [];\n    dynamicViews = [];\n    constructor(renderer, eventManagerFactory, widgetRegistry, injector, environmentInjector) {\n        this.renderer = renderer;\n        this.eventManagerFactory = eventManagerFactory;\n        this.widgetRegistry = widgetRegistry;\n        this.injector = injector;\n        this.environmentInjector = environmentInjector;\n    }\n    ngOnInit() {\n        // this.updateWidgetHtml();\n    }\n    ngOnChanges(changes) {\n        if (changes['widgets']) {\n            this.updateWidgetHtml();\n        }\n    }\n    ngAfterViewInit() {\n        this.updateWidgetHtml();\n        this.isViewInitialized = true;\n        this.setupEventHandlers();\n        // Render dynamic components/templates after view init\n        this.renderDynamicWidgets();\n    }\n    ngOnDestroy() {\n        this.cleanup();\n    }\n    /**\n     * Base implementation for updating the rendered HTML for the current widgets.\n     *\n     * Subclasses may override this method to customize how widgets are rendered\n     * (for example, to inject additional markup or perform preprocessing).\n     *\n     * Since this is the base implementation, overriding implementations are not\n     * required to call `super.updateWidgetHtml()`.\n     */\n    updateWidgetHtml() {\n        if (!this.widgets || this.widgets.length === 0) {\n            this.widgetItems = [];\n            return;\n        }\n        this.widgetItems = this.widgets.map((widget, index) => {\n            const customRenderer = this.widgetRegistry.getRenderer(widget.type);\n            // Check template renderer first (most specific)\n            if (customRenderer && isTemplateRenderer(customRenderer)) {\n                return {\n                    index,\n                    widget,\n                    isHtml: false,\n                };\n            }\n            // Check component renderer second\n            if (customRenderer && isComponentRenderer(customRenderer)) {\n                return {\n                    index,\n                    widget,\n                    isHtml: false,\n                };\n            }\n            // Check HTML function renderer last (most general, matches any function)\n            if (customRenderer && isHtmlRenderer(customRenderer)) {\n                return {\n                    index,\n                    widget,\n                    isHtml: true,\n                    html: customRenderer(widget),\n                };\n            }\n            // Default: render using the BbQ library renderer\n            return {\n                index,\n                widget,\n                isHtml: true,\n                html: this.renderer.renderWidget(widget),\n            };\n        });\n        // After view updates, reinitialize widgets only if view is already initialized\n        if (this.isViewInitialized) {\n            setTimeout(() => {\n                this.setupEventHandlers();\n                this.renderDynamicWidgets();\n            }, 0);\n        }\n    }\n    /**\n     * Render dynamic components and templates for custom widgets\n     */\n    renderDynamicWidgets() {\n        if (!this.containerRef?.nativeElement)\n            return;\n        // Use microtask to ensure Angular has completed change detection\n        Promise.resolve().then(() => {\n            if (!this.containerRef?.nativeElement)\n                return;\n            // Clean up existing dynamic components and views\n            this.cleanupDynamicWidgets();\n            const container = this.containerRef.nativeElement;\n            // Query all widget divs without the data-rendered filter\n            const dynamicWidgetDivs = Array.from(container.querySelectorAll('.bbq-widget'));\n            let dynamicIndex = 0;\n            this.widgetItems.forEach((item) => {\n                if (!item.isHtml) {\n                    const customRenderer = this.widgetRegistry.getRenderer(item.widget.type);\n                    if (!customRenderer)\n                        return;\n                    const targetDiv = dynamicWidgetDivs[dynamicIndex];\n                    if (!targetDiv)\n                        return;\n                    // Clear the div content before rendering\n                    targetDiv.innerHTML = '';\n                    if (isComponentRenderer(customRenderer)) {\n                        this.renderComponent(customRenderer, item.widget, targetDiv);\n                    }\n                    else if (isTemplateRenderer(customRenderer)) {\n                        this.renderTemplate(customRenderer, item.widget, targetDiv);\n                    }\n                    dynamicIndex++;\n                }\n            });\n        });\n    }\n    /**\n     * Render an Angular component for a custom widget\n     *\n     * Note: This method safely assigns properties to component instances\n     * by checking for property existence at runtime. This approach is necessary\n     * because we cannot statically verify that all components implement\n     * the CustomWidgetComponent interface.\n     */\n    renderComponent(componentType, widget, targetElement) {\n        // Create the component using Angular's createComponent API\n        const componentRef = createComponent(componentType, {\n            environmentInjector: this.environmentInjector,\n            elementInjector: this.injector,\n        });\n        // Safely set component inputs if they exist\n        const instance = componentRef.instance;\n        if (instance && typeof instance === 'object') {\n            // Set widget property if it exists in the prototype chain\n            if ('widget' in instance) {\n                instance.widget = widget;\n            }\n            // Set widgetAction callback if it exists in the prototype chain\n            if ('widgetAction' in instance) {\n                instance.widgetAction = (actionName, payload) => {\n                    this.widgetAction.emit({ actionName, payload });\n                };\n            }\n        }\n        // Attach the component's host view to the target element\n        targetElement.appendChild(componentRef.location.nativeElement);\n        // Store reference for cleanup\n        this.dynamicComponents.push(componentRef);\n        // Trigger change detection (use optional chaining for safety)\n        componentRef.changeDetectorRef?.detectChanges();\n    }\n    /**\n     * Render an Angular template for a custom widget\n     */\n    renderTemplate(templateRef, widget, targetElement) {\n        const context = {\n            $implicit: widget,\n            widget: widget,\n            emitAction: (actionName, payload) => {\n                this.widgetAction.emit({ actionName, payload });\n            },\n        };\n        const viewRef = templateRef.createEmbeddedView(context);\n        // Attach the view's DOM nodes to the target element\n        viewRef.rootNodes.forEach((node) => {\n            targetElement.appendChild(node);\n        });\n        // Store reference for cleanup\n        this.dynamicViews.push(viewRef);\n        // Trigger change detection\n        viewRef.detectChanges();\n    }\n    /**\n     * Cleanup dynamic components and views\n     */\n    cleanupDynamicWidgets() {\n        this.dynamicComponents.forEach((componentRef) => {\n            componentRef.destroy();\n        });\n        this.dynamicComponents = [];\n        this.dynamicViews.forEach((viewRef) => {\n            viewRef.destroy();\n        });\n        this.dynamicViews = [];\n    }\n    setupEventHandlers() {\n        if (!this.containerRef?.nativeElement)\n            return;\n        // Cleanup old resources before setting up new ones\n        this.cleanup();\n        const container = this.containerRef.nativeElement;\n        // Create a custom action handler that emits events\n        const actionHandler = {\n            handle: async (action, payload) => {\n                this.widgetAction.emit({ actionName: action, payload });\n            },\n        };\n        // Use the injected factory to create an event manager with the component-specific action handler\n        this.eventManager = this.eventManagerFactory(actionHandler);\n        this.eventManager.attachHandlers(container);\n    }\n    handleClick(event) {\n        const target = event.target;\n        // Only trigger actions on non-form buttons and clickable elements (cards)\n        // Don't trigger on input elements or form buttons (let WidgetEventManager handle those)\n        const button = target.tagName === 'BUTTON' ? target : target.closest('button');\n        if (button && !button.closest('[data-widget-type=\"form\"]')) {\n            const actionName = button.getAttribute('data-action');\n            if (actionName) {\n                try {\n                    const payloadStr = button.getAttribute('data-payload');\n                    const payload = payloadStr ? JSON.parse(payloadStr) : {};\n                    this.widgetAction.emit({ actionName, payload });\n                }\n                catch (err) {\n                    console.error('Failed to parse widget action payload:', err);\n                }\n            }\n        }\n    }\n    /**\n     * Cleanup all resources including event listeners.\n     */\n    cleanup() {\n        // Cleanup dynamic widgets first\n        this.cleanupDynamicWidgets();\n        // Cleanup event manager\n        this.eventManager = undefined;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRendererComponent, deps: [{ token: SSR_WIDGET_RENDERER }, { token: WIDGET_EVENT_MANAGER_FACTORY }, { token: WidgetRegistryService }, { token: i0.Injector }, { token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.0.0\", version: \"21.0.8\", type: WidgetRendererComponent, isStandalone: true, selector: \"bbq-widget-renderer\", inputs: { widgets: \"widgets\" }, outputs: { widgetAction: \"widgetAction\" }, providers: [\n            { provide: WIDGET_EVENT_MANAGER_FACTORY, useFactory: widgetEventManagerFactoryProvider },\n            { provide: SSR_WIDGET_RENDERER, useFactory: ssrWidgetRendererFactory },\n        ], viewQueries: [{ propertyName: \"containerRef\", first: true, predicate: [\"widgetContainer\"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `\r\n    <div #widgetContainer class=\"bbq-widgets-container\" (click)=\"handleClick($event)\">\r\n      @for (item of widgetItems; track item.index) {\r\n        @if (item.isHtml) {\r\n          <div class=\"bbq-widget\" [innerHTML]=\"item.html\"></div>\r\n        } @else {\r\n          <div class=\"bbq-widget\" #dynamicWidget></div>\r\n        }\r\n      }\r\n    </div>\r\n  `, isInline: true, styles: [\".bbq-widgets-container{margin-top:.5rem}.bbq-widget{margin-bottom:.5rem}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"21.0.8\", ngImport: i0, type: WidgetRendererComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'bbq-widget-renderer', standalone: true, imports: [CommonModule], providers: [\n                        { provide: WIDGET_EVENT_MANAGER_FACTORY, useFactory: widgetEventManagerFactoryProvider },\n                        { provide: SSR_WIDGET_RENDERER, useFactory: ssrWidgetRendererFactory },\n                    ], template: `\r\n    <div #widgetContainer class=\"bbq-widgets-container\" (click)=\"handleClick($event)\">\r\n      @for (item of widgetItems; track item.index) {\r\n        @if (item.isHtml) {\r\n          <div class=\"bbq-widget\" [innerHTML]=\"item.html\"></div>\r\n        } @else {\r\n          <div class=\"bbq-widget\" #dynamicWidget></div>\r\n        }\r\n      }\r\n    </div>\r\n  `, styles: [\".bbq-widgets-container{margin-top:.5rem}.bbq-widget{margin-bottom:.5rem}\\n\"] }]\n        }], ctorParameters: () => [{ type: i2.SsrWidgetRenderer, decorators: [{\n                    type: Inject,\n                    args: [SSR_WIDGET_RENDERER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [WIDGET_EVENT_MANAGER_FACTORY]\n                }] }, { type: WidgetRegistryService }, { type: i0.Injector }, { type: i0.EnvironmentInjector }], propDecorators: { widgets: [{\n                type: Input\n            }], widgetAction: [{\n                type: Output\n            }], containerRef: [{\n                type: ViewChild,\n                args: ['widgetContainer', { static: false }]\n            }] } });\n\n/**\n * @bbq-chat/widgets-angular\n *\n * Angular components and services for BbQ ChatWidgets\n *\n * This package provides Angular-native components and services that wrap\n * the core @bbq-chat/widgets library, making it easy to integrate chat\n * widgets into Angular applications.\n *\n * @packageDocumentation\n */\n// Export components\n// Version\nconst VERSION = '1.0.2';\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SSR_WIDGET_RENDERER, VERSION, WIDGET_EVENT_MANAGER_FACTORY, WidgetRegistryService, WidgetRendererComponent, isComponentRenderer, isHtmlRenderer, isTemplateRenderer, ssrWidgetRendererFactory, widgetEventManagerFactoryProvider };\n//# sourceMappingURL=index.mjs.map\n","map":null,"preliminaryFileName":"index.mjs","sourcemapFileName":"index.mjs.map"},{"fileName":"index.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"index.mjs\",\"sources\":[\"../../src/custom-widget-renderer.types.ts\",\"../../src/widget-di.tokens.ts\",\"../../src/widget-registry.service.ts\",\"../../src/widget-renderer.component.ts\",\"../../src/public_api.ts\",\"../../src/index.ts\"],\"sourcesContent\":[\"import { Type, TemplateRef } from '@angular/core';\\r\\nimport { ChatWidget } from '@bbq-chat/widgets';\\r\\n\\r\\n/**\\r\\n * Context provided to template-based custom widget renderers\\r\\n */\\r\\nexport interface WidgetTemplateContext {\\r\\n  /**\\r\\n   * The widget instance being rendered\\r\\n   */\\r\\n  $implicit: ChatWidget;\\r\\n  \\r\\n  /**\\r\\n   * The widget instance (alternative access)\\r\\n   */\\r\\n  widget: ChatWidget;\\r\\n  \\r\\n  /**\\r\\n   * Emit a widget action\\r\\n   */\\r\\n  emitAction: (actionName: string, payload: unknown) => void;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Interface for component-based custom widget renderers\\r\\n */\\r\\nexport interface CustomWidgetComponent {\\r\\n  /**\\r\\n   * The widget instance to render\\r\\n   */\\r\\n  widget: ChatWidget;\\r\\n  \\r\\n  /**\\r\\n   * Event emitter for widget actions (optional, will be set by the renderer)\\r\\n   */\\r\\n  widgetAction?: (actionName: string, payload: unknown) => void;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Type for custom widget renderer functions that return HTML strings\\r\\n */\\r\\nexport type CustomWidgetHtmlRenderer = (widget: ChatWidget) => string;\\r\\n\\r\\n/**\\r\\n * Type for custom widget renderer configurations\\r\\n */\\r\\nexport type CustomWidgetRenderer =\\r\\n  | CustomWidgetHtmlRenderer\\r\\n  | Type<CustomWidgetComponent>\\r\\n  | TemplateRef<WidgetTemplateContext>;\\r\\n\\r\\n/**\\r\\n * Configuration for registering a custom widget renderer\\r\\n */\\r\\nexport interface CustomWidgetRendererConfig {\\r\\n  /**\\r\\n   * The widget type identifier\\r\\n   */\\r\\n  type: string;\\r\\n  \\r\\n  /**\\r\\n   * The renderer: can be a function returning HTML, an Angular Component class, or a TemplateRef\\r\\n   */\\r\\n  renderer: CustomWidgetRenderer;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Type guard to check if a renderer is a TemplateRef\\r\\n */\\r\\nexport function isTemplateRenderer(\\r\\n  renderer: CustomWidgetRenderer\\r\\n): renderer is TemplateRef<WidgetTemplateContext> {\\r\\n  return (\\r\\n    renderer !== null &&\\r\\n    typeof renderer === 'object' &&\\r\\n    'createEmbeddedView' in renderer\\r\\n  );\\r\\n}\\r\\n\\r\\n/**\\r\\n * Type guard to check if a renderer is an Angular Component\\r\\n * \\r\\n * Note: This uses a heuristic check based on the following assumptions:\\r\\n * 1. Components are constructor functions\\r\\n * 2. Components have a prototype with a constructor property\\r\\n * 3. Components typically use dependency injection (no required constructor params)\\r\\n * \\r\\n * Limitation: This may not detect components with required constructor parameters.\\r\\n * For edge cases, explicitly check your component's constructor signature.\\r\\n * \\r\\n * Alternative: You can always register a wrapper component that has no required params.\\r\\n */\\r\\nexport function isComponentRenderer(\\r\\n  renderer: CustomWidgetRenderer\\r\\n): renderer is Type<CustomWidgetComponent> {\\r\\n  // Check if it's a function (constructor) but not a regular function renderer\\r\\n  if (typeof renderer !== 'function') {\\r\\n    return false;\\r\\n  }\\r\\n  \\r\\n  // Check for Angular component characteristics\\r\\n  // Components typically have prototype with constructor property\\r\\n  return (\\r\\n    renderer.prototype !== undefined &&\\r\\n    renderer.prototype.constructor === renderer &&\\r\\n    renderer.length === 0 // Constructor with no required params (Angular DI)\\r\\n  );\\r\\n}\\r\\n\\r\\n/**\\r\\n * Type guard to check if a renderer is an HTML function\\r\\n * \\r\\n * Note: This should be checked AFTER checking for component and template renderers\\r\\n * since components are also functions but with additional properties.\\r\\n */\\r\\nexport function isHtmlRenderer(\\r\\n  renderer: CustomWidgetRenderer\\r\\n): renderer is CustomWidgetHtmlRenderer {\\r\\n  return typeof renderer === 'function';\\r\\n}\\r\\n\",\"import { InjectionToken } from '@angular/core';\\r\\nimport { SsrWidgetRenderer, WidgetEventManager, IWidgetActionHandler } from '@bbq-chat/widgets';\\r\\n\\r\\n/**\\r\\n * Injection token for WidgetEventManager factory\\r\\n * \\r\\n * Use this token to inject a factory function that creates WidgetEventManager instances.\\r\\n * The factory accepts an optional action handler to configure the manager.\\r\\n * \\r\\n * @example\\r\\n * ```typescript\\r\\n * constructor(@Inject(WIDGET_EVENT_MANAGER_FACTORY) private eventManagerFactory: WidgetEventManagerFactory) {\\r\\n *   const actionHandler = { handle: async (action, payload) => { ... } };\\r\\n *   this.eventManager = this.eventManagerFactory(actionHandler);\\r\\n * }\\r\\n * ```\\r\\n */\\r\\nexport type WidgetEventManagerFactory = (actionHandler?: IWidgetActionHandler) => WidgetEventManager;\\r\\n\\r\\nexport const WIDGET_EVENT_MANAGER_FACTORY = new InjectionToken<WidgetEventManagerFactory>(\\r\\n  'WIDGET_EVENT_MANAGER_FACTORY'\\r\\n);\\r\\n\\r\\n/**\\r\\n * Injection token for SsrWidgetRenderer\\r\\n * \\r\\n * Use this token to inject a SsrWidgetRenderer instance in your components.\\r\\n * By default, WidgetRendererComponent provides this token with a factory that creates\\r\\n * a new instance for each component.\\r\\n * \\r\\n * @example\\r\\n * ```typescript\\r\\n * constructor(@Inject(SSR_WIDGET_RENDERER) private renderer: SsrWidgetRenderer) {}\\r\\n * ```\\r\\n */\\r\\nexport const SSR_WIDGET_RENDERER = new InjectionToken<SsrWidgetRenderer>(\\r\\n  'SSR_WIDGET_RENDERER'\\r\\n);\\r\\n\\r\\n/**\\r\\n * Factory function for creating WidgetEventManager instances\\r\\n * \\r\\n * This factory is used by default in WidgetRendererComponent's providers array.\\r\\n * You can override this in your own providers if you need custom initialization.\\r\\n * \\r\\n * @returns A factory function that creates WidgetEventManager instances\\r\\n */\\r\\nexport function widgetEventManagerFactoryProvider(): WidgetEventManagerFactory {\\r\\n  return (actionHandler?: IWidgetActionHandler) => new WidgetEventManager(actionHandler);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Factory function for creating SsrWidgetRenderer instances\\r\\n * \\r\\n * This factory is used by default in WidgetRendererComponent's providers array.\\r\\n * You can override this in your own providers if you need custom initialization\\r\\n * or custom rendering options.\\r\\n * \\r\\n * @returns A new SsrWidgetRenderer instance\\r\\n */\\r\\nexport function ssrWidgetRendererFactory(): SsrWidgetRenderer {\\r\\n  return new SsrWidgetRenderer();\\r\\n}\\r\\n\",\"import { Injectable } from '@angular/core';\\r\\nimport { customWidgetRegistry, ChatWidget } from '@bbq-chat/widgets';\\r\\nimport { CustomWidgetRenderer } from './custom-widget-renderer.types';\\r\\n\\r\\n/**\\r\\n * Service for registering custom widget factories and renderers\\r\\n * \\r\\n * This service provides a centralized way to register custom widget types\\r\\n * that extend the base widget functionality, including support for\\r\\n * Angular components and templates as custom renderers.\\r\\n * \\r\\n * @example\\r\\n * ```typescript\\r\\n * constructor(private widgetRegistry: WidgetRegistryService) {\\r\\n *   // Register a widget factory\\r\\n *   this.widgetRegistry.registerFactory('myWidget', (obj) => {\\r\\n *     if (obj.type === 'myWidget') {\\r\\n *       return new MyCustomWidget(obj.label, obj.action);\\r\\n *     }\\r\\n *     return null;\\r\\n *   });\\r\\n * \\r\\n *   // Register a component-based renderer\\r\\n *   this.widgetRegistry.registerRenderer('myWidget', MyWidgetComponent);\\r\\n * }\\r\\n * ```\\r\\n */\\r\\n@Injectable({\\r\\n  providedIn: 'root',\\r\\n})\\r\\nexport class WidgetRegistryService {\\r\\n  private readonly customRenderers = new Map<string, CustomWidgetRenderer>();\\r\\n  /**\\r\\n   * Register a custom widget factory function\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @param factory - Factory function that creates widget instances from plain objects\\r\\n   */\\r\\n  registerFactory(\\r\\n    type: string,\\r\\n    factory: (obj: unknown) => ChatWidget | null\\r\\n  ): void {\\r\\n    customWidgetRegistry.registerFactory(type, factory);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Register a widget class with automatic factory creation\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @param ctor - Widget class constructor\\r\\n   */\\r\\n  registerClass(type: string, ctor: any): void {\\r\\n    customWidgetRegistry.registerClass(type, ctor);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get a factory for a specific widget type\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @returns The factory function if registered, undefined otherwise\\r\\n   */\\r\\n  getFactory(type: string): ((obj: any) => ChatWidget | null) | undefined {\\r\\n    return customWidgetRegistry.getFactory(type);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Register a custom renderer for a specific widget type\\r\\n   * \\r\\n   * The renderer can be:\\r\\n   * - A function that returns HTML string\\r\\n   * - An Angular Component class\\r\\n   * - An Angular TemplateRef\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @param renderer - The custom renderer (function, Component, or TemplateRef)\\r\\n   * \\r\\n   * @example\\r\\n   * ```typescript\\r\\n   * // HTML function renderer\\r\\n   * widgetRegistry.registerRenderer('weather', (widget) => `<div>${widget.label}</div>`);\\r\\n   * \\r\\n   * // Component renderer\\r\\n   * widgetRegistry.registerRenderer('weather', WeatherWidgetComponent);\\r\\n   * \\r\\n   * // Template renderer (from @ViewChild or elsewhere)\\r\\n   * widgetRegistry.registerRenderer('weather', this.weatherTemplate);\\r\\n   * ```\\r\\n   */\\r\\n  registerRenderer(type: string, renderer: CustomWidgetRenderer): void {\\r\\n    if (!type || typeof type !== 'string') {\\r\\n      throw new Error('type must be a non-empty string');\\r\\n    }\\r\\n    if (!renderer) {\\r\\n      throw new Error('renderer is required');\\r\\n    }\\r\\n    this.customRenderers.set(type, renderer);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get a custom renderer for a specific widget type\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @returns The custom renderer if registered, undefined otherwise\\r\\n   */\\r\\n  getRenderer(type: string): CustomWidgetRenderer | undefined {\\r\\n    return this.customRenderers.get(type);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Check if a custom renderer is registered for a widget type\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @returns True if a custom renderer is registered, false otherwise\\r\\n   */\\r\\n  hasRenderer(type: string): boolean {\\r\\n    return this.customRenderers.has(type);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Unregister a custom renderer for a widget type\\r\\n   * \\r\\n   * @param type - The widget type identifier\\r\\n   * @returns True if a renderer was removed, false if none was registered\\r\\n   */\\r\\n  unregisterRenderer(type: string): boolean {\\r\\n    return this.customRenderers.delete(type);\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  Component,\\r\\n  Input,\\r\\n  Output,\\r\\n  EventEmitter,\\r\\n  ElementRef,\\r\\n  AfterViewInit,\\r\\n  OnInit,\\r\\n  OnDestroy,\\r\\n  OnChanges,\\r\\n  SimpleChanges,\\r\\n  ViewChild,\\r\\n  ComponentRef,\\r\\n  EmbeddedViewRef,\\r\\n  TemplateRef,\\r\\n  Injector,\\r\\n  createComponent,\\r\\n  EnvironmentInjector,\\r\\n  Inject,\\r\\n} from '@angular/core';\\r\\nimport { CommonModule } from '@angular/common';\\r\\nimport {\\r\\n  SsrWidgetRenderer,\\r\\n  WidgetEventManager,\\r\\n  ChatWidget,\\r\\n} from '@bbq-chat/widgets';\\r\\nimport { WidgetRegistryService } from './widget-registry.service';\\r\\nimport {\\r\\n  WidgetTemplateContext,\\r\\n  isHtmlRenderer,\\r\\n  isComponentRenderer,\\r\\n  isTemplateRenderer,\\r\\n} from './custom-widget-renderer.types';\\r\\nimport {\\r\\n  WIDGET_EVENT_MANAGER_FACTORY,\\r\\n  SSR_WIDGET_RENDERER,\\r\\n  widgetEventManagerFactoryProvider,\\r\\n  ssrWidgetRendererFactory,\\r\\n  WidgetEventManagerFactory,\\r\\n} from './widget-di.tokens';\\r\\n\\r\\n/**\\r\\n * Angular component for rendering chat widgets\\r\\n * \\r\\n * This component handles rendering of chat widgets using the BbQ ChatWidgets library.\\r\\n * It manages widget lifecycle, event handling, and cleanup. \\r\\n * \\r\\n * Supports three types of custom widget renderers:\\r\\n * 1. HTML function renderers (return HTML strings)\\r\\n * 2. Angular Component renderers (render as dynamic components)\\r\\n * 3. Angular TemplateRef renderers (render as embedded views)\\r\\n * \\r\\n * @example\\r\\n * ```typescript\\r\\n * <bbq-widget-renderer \\r\\n *   [widgets]=\\\"messageWidgets\\\" \\r\\n *   (widgetAction)=\\\"handleWidgetAction($event)\\\">\\r\\n * </bbq-widget-renderer>\\r\\n * ```\\r\\n */\\r\\n@Component({\\r\\n  selector: 'bbq-widget-renderer',\\r\\n  standalone: true,\\r\\n  imports: [CommonModule],\\r\\n  providers: [\\r\\n    { provide: WIDGET_EVENT_MANAGER_FACTORY, useFactory: widgetEventManagerFactoryProvider },\\r\\n    { provide: SSR_WIDGET_RENDERER, useFactory: ssrWidgetRendererFactory },\\r\\n  ],\\r\\n  template: `\\r\\n    <div #widgetContainer class=\\\"bbq-widgets-container\\\" (click)=\\\"handleClick($event)\\\">\\r\\n      @for (item of widgetItems; track item.index) {\\r\\n        @if (item.isHtml) {\\r\\n          <div class=\\\"bbq-widget\\\" [innerHTML]=\\\"item.html\\\"></div>\\r\\n        } @else {\\r\\n          <div class=\\\"bbq-widget\\\" #dynamicWidget></div>\\r\\n        }\\r\\n      }\\r\\n    </div>\\r\\n  `,\\r\\n  styles: [\\r\\n    `\\r\\n      .bbq-widgets-container {\\r\\n        margin-top: 0.5rem;\\r\\n      }\\r\\n\\r\\n      .bbq-widget {\\r\\n        margin-bottom: 0.5rem;\\r\\n      }\\r\\n    `,\\r\\n  ],\\r\\n})\\r\\nexport class WidgetRendererComponent\\r\\n  implements OnInit, AfterViewInit, OnDestroy, OnChanges\\r\\n{\\r\\n  /**\\r\\n   * Array of widgets to render\\r\\n   */\\r\\n  @Input() widgets: ChatWidget[] | null | undefined;\\r\\n\\r\\n  /**\\r\\n   * Emits when a widget action is triggered\\r\\n   */\\r\\n  @Output() widgetAction = new EventEmitter<{\\r\\n    actionName: string;\\r\\n    payload: unknown;\\r\\n  }>();\\r\\n\\r\\n  @ViewChild('widgetContainer', { static: false })\\r\\n  containerRef!: ElementRef<HTMLDivElement>;\\r\\n\\r\\n  protected widgetItems: Array<{\\r\\n    index: number;\\r\\n    widget: ChatWidget;\\r\\n    isHtml: boolean;\\r\\n    html?: string;\\r\\n  }> = [];\\r\\n  \\r\\n  protected eventManager?: WidgetEventManager;\\r\\n  protected isViewInitialized = false;\\r\\n  protected dynamicComponents: Array<ComponentRef<any>> = [];\\r\\n  protected dynamicViews: Array<EmbeddedViewRef<WidgetTemplateContext>> = [];\\r\\n\\r\\n  constructor(\\r\\n    @Inject(SSR_WIDGET_RENDERER) protected renderer: SsrWidgetRenderer,\\r\\n    @Inject(WIDGET_EVENT_MANAGER_FACTORY) protected eventManagerFactory: WidgetEventManagerFactory,\\r\\n    protected widgetRegistry: WidgetRegistryService,\\r\\n    protected injector: Injector,\\r\\n    protected environmentInjector: EnvironmentInjector\\r\\n  ) {}\\r\\n\\r\\n  ngOnInit() {\\r\\n    // this.updateWidgetHtml();\\r\\n  }\\r\\n\\r\\n  ngOnChanges(changes: SimpleChanges) {\\r\\n    if (changes['widgets']) {\\r\\n      this.updateWidgetHtml();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  ngAfterViewInit() {\\r\\n    this.updateWidgetHtml();\\r\\n    this.isViewInitialized = true;\\r\\n    this.setupEventHandlers();\\r\\n    // Render dynamic components/templates after view init\\r\\n    this.renderDynamicWidgets();\\r\\n  }\\r\\n\\r\\n  ngOnDestroy() {\\r\\n    this.cleanup();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Base implementation for updating the rendered HTML for the current widgets.\\r\\n   *\\r\\n   * Subclasses may override this method to customize how widgets are rendered\\r\\n   * (for example, to inject additional markup or perform preprocessing).\\r\\n   *\\r\\n   * Since this is the base implementation, overriding implementations are not\\r\\n   * required to call `super.updateWidgetHtml()`.\\r\\n   */\\r\\n  protected updateWidgetHtml() {\\r\\n    if (!this.widgets || this.widgets.length === 0) {\\r\\n      this.widgetItems = [];\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    this.widgetItems = this.widgets.map((widget, index) => {\\r\\n      const customRenderer = this.widgetRegistry.getRenderer(widget.type);\\r\\n      \\r\\n      // Check template renderer first (most specific)\\r\\n      if (customRenderer && isTemplateRenderer(customRenderer)) {\\r\\n        return {\\r\\n          index,\\r\\n          widget,\\r\\n          isHtml: false,\\r\\n        };\\r\\n      }\\r\\n      \\r\\n      // Check component renderer second\\r\\n      if (customRenderer && isComponentRenderer(customRenderer)) {\\r\\n        return {\\r\\n          index,\\r\\n          widget,\\r\\n          isHtml: false,\\r\\n        };\\r\\n      }\\r\\n      \\r\\n      // Check HTML function renderer last (most general, matches any function)\\r\\n      if (customRenderer && isHtmlRenderer(customRenderer)) {\\r\\n        return {\\r\\n          index,\\r\\n          widget,\\r\\n          isHtml: true,\\r\\n          html: customRenderer(widget),\\r\\n        };\\r\\n      }\\r\\n      \\r\\n      // Default: render using the BbQ library renderer\\r\\n      return {\\r\\n        index,\\r\\n        widget,\\r\\n        isHtml: true,\\r\\n        html: this.renderer.renderWidget(widget),\\r\\n      };\\r\\n    });\\r\\n\\r\\n    // After view updates, reinitialize widgets only if view is already initialized\\r\\n    if (this.isViewInitialized) {\\r\\n      setTimeout(() => {\\r\\n        this.setupEventHandlers();\\r\\n        this.renderDynamicWidgets();\\r\\n      }, 0);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Render dynamic components and templates for custom widgets\\r\\n   */\\r\\n  protected renderDynamicWidgets() {\\r\\n    if (!this.containerRef?.nativeElement) return;\\r\\n    \\r\\n    // Use microtask to ensure Angular has completed change detection\\r\\n    Promise.resolve().then(() => {\\r\\n      if (!this.containerRef?.nativeElement) return;\\r\\n      \\r\\n      // Clean up existing dynamic components and views\\r\\n      this.cleanupDynamicWidgets();\\r\\n\\r\\n      const container = this.containerRef.nativeElement;\\r\\n      // Query all widget divs without the data-rendered filter\\r\\n      const dynamicWidgetDivs = Array.from(\\r\\n        container.querySelectorAll('.bbq-widget')\\r\\n      ) as HTMLElement[];\\r\\n      \\r\\n      let dynamicIndex = 0;\\r\\n      this.widgetItems.forEach((item) => {\\r\\n        if (!item.isHtml) {\\r\\n          const customRenderer = this.widgetRegistry.getRenderer(item.widget.type);\\r\\n          \\r\\n          if (!customRenderer) return;\\r\\n          \\r\\n          const targetDiv = dynamicWidgetDivs[dynamicIndex];\\r\\n          if (!targetDiv) return;\\r\\n          \\r\\n          // Clear the div content before rendering\\r\\n          targetDiv.innerHTML = '';\\r\\n          \\r\\n          if (isComponentRenderer(customRenderer)) {\\r\\n            this.renderComponent(customRenderer, item.widget, targetDiv);\\r\\n          } else if (isTemplateRenderer(customRenderer)) {\\r\\n            this.renderTemplate(customRenderer, item.widget, targetDiv);\\r\\n          }\\r\\n          \\r\\n          dynamicIndex++;\\r\\n        }\\r\\n      });\\r\\n    });\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Render an Angular component for a custom widget\\r\\n   * \\r\\n   * Note: This method safely assigns properties to component instances\\r\\n   * by checking for property existence at runtime. This approach is necessary\\r\\n   * because we cannot statically verify that all components implement\\r\\n   * the CustomWidgetComponent interface.\\r\\n   */\\r\\n  protected renderComponent(\\r\\n    componentType: any,\\r\\n    widget: ChatWidget,\\r\\n    targetElement: HTMLElement\\r\\n  ) {\\r\\n    // Create the component using Angular's createComponent API\\r\\n    const componentRef = createComponent(componentType, {\\r\\n      environmentInjector: this.environmentInjector,\\r\\n      elementInjector: this.injector,\\r\\n    });\\r\\n    \\r\\n    // Safely set component inputs if they exist\\r\\n    const instance = componentRef.instance;\\r\\n    if (instance && typeof instance === 'object') {\\r\\n      // Set widget property if it exists in the prototype chain\\r\\n      if ('widget' in instance) {\\r\\n        (instance as any).widget = widget;\\r\\n      }\\r\\n      \\r\\n      // Set widgetAction callback if it exists in the prototype chain\\r\\n      if ('widgetAction' in instance) {\\r\\n        (instance as any).widgetAction = (actionName: string, payload: unknown) => {\\r\\n          this.widgetAction.emit({ actionName, payload });\\r\\n        };\\r\\n      }\\r\\n    }\\r\\n    \\r\\n    // Attach the component's host view to the target element\\r\\n    targetElement.appendChild(componentRef.location.nativeElement);\\r\\n    \\r\\n    // Store reference for cleanup\\r\\n    this.dynamicComponents.push(componentRef);\\r\\n    \\r\\n    // Trigger change detection (use optional chaining for safety)\\r\\n    componentRef.changeDetectorRef?.detectChanges();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Render an Angular template for a custom widget\\r\\n   */\\r\\n  protected renderTemplate(\\r\\n    templateRef: TemplateRef<WidgetTemplateContext>,\\r\\n    widget: ChatWidget,\\r\\n    targetElement: HTMLElement\\r\\n  ) {\\r\\n    const context: WidgetTemplateContext = {\\r\\n      $implicit: widget,\\r\\n      widget: widget,\\r\\n      emitAction: (actionName: string, payload: unknown) => {\\r\\n        this.widgetAction.emit({ actionName, payload });\\r\\n      },\\r\\n    };\\r\\n    \\r\\n    const viewRef = templateRef.createEmbeddedView(context);\\r\\n    \\r\\n    // Attach the view's DOM nodes to the target element\\r\\n    viewRef.rootNodes.forEach((node: Node) => {\\r\\n      targetElement.appendChild(node);\\r\\n    });\\r\\n    \\r\\n    // Store reference for cleanup\\r\\n    this.dynamicViews.push(viewRef);\\r\\n    \\r\\n    // Trigger change detection\\r\\n    viewRef.detectChanges();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Cleanup dynamic components and views\\r\\n   */\\r\\n  protected cleanupDynamicWidgets() {\\r\\n    this.dynamicComponents.forEach((componentRef) => {\\r\\n      componentRef.destroy();\\r\\n    });\\r\\n    this.dynamicComponents = [];\\r\\n    \\r\\n    this.dynamicViews.forEach((viewRef) => {\\r\\n      viewRef.destroy();\\r\\n    });\\r\\n    this.dynamicViews = [];\\r\\n  }\\r\\n\\r\\n  private setupEventHandlers() {\\r\\n    if (!this.containerRef?.nativeElement) return;\\r\\n\\r\\n    // Cleanup old resources before setting up new ones\\r\\n    this.cleanup();\\r\\n\\r\\n    const container = this.containerRef.nativeElement;\\r\\n\\r\\n    // Create a custom action handler that emits events\\r\\n    const actionHandler = {\\r\\n      handle: async (action: string, payload: any) => {\\r\\n        this.widgetAction.emit({ actionName: action, payload });\\r\\n      },\\r\\n    };\\r\\n\\r\\n    // Use the injected factory to create an event manager with the component-specific action handler\\r\\n    this.eventManager = this.eventManagerFactory(actionHandler);\\r\\n    this.eventManager.attachHandlers(container);\\r\\n  }\\r\\n\\r\\n  handleClick(event: MouseEvent) {\\r\\n    const target = event.target as HTMLElement;\\r\\n    // Only trigger actions on non-form buttons and clickable elements (cards)\\r\\n    // Don't trigger on input elements or form buttons (let WidgetEventManager handle those)\\r\\n    const button = target.tagName === 'BUTTON' ? target : target.closest('button');\\r\\n    if (button && !button.closest('[data-widget-type=\\\"form\\\"]')) {\\r\\n      const actionName = button.getAttribute('data-action');\\r\\n      if (actionName) {\\r\\n        try {\\r\\n          const payloadStr = button.getAttribute('data-payload');\\r\\n          const payload = payloadStr ? JSON.parse(payloadStr) : {};\\r\\n          this.widgetAction.emit({ actionName, payload });\\r\\n        } catch (err) {\\r\\n          console.error('Failed to parse widget action payload:', err);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Cleanup all resources including event listeners.\\r\\n   */\\r\\n  private cleanup() {\\r\\n    // Cleanup dynamic widgets first\\r\\n    this.cleanupDynamicWidgets();\\r\\n    \\r\\n    // Cleanup event manager\\r\\n    this.eventManager = undefined;\\r\\n  }\\r\\n}\\r\\n\",\"/**\\r\\n * @bbq-chat/widgets-angular\\r\\n * \\r\\n * Angular components and services for BbQ ChatWidgets\\r\\n * \\r\\n * This package provides Angular-native components and services that wrap\\r\\n * the core @bbq-chat/widgets library, making it easy to integrate chat\\r\\n * widgets into Angular applications.\\r\\n * \\r\\n * @packageDocumentation\\r\\n */\\r\\n\\r\\n// Export components\\r\\nexport { WidgetRendererComponent } from './widget-renderer.component';\\r\\n\\r\\n// Export services\\r\\nexport { WidgetRegistryService } from './widget-registry.service';\\r\\n\\r\\n// Export DI tokens and factories\\r\\nexport {\\r\\n  WIDGET_EVENT_MANAGER_FACTORY,\\r\\n  SSR_WIDGET_RENDERER,\\r\\n  widgetEventManagerFactoryProvider,\\r\\n  ssrWidgetRendererFactory,\\r\\n} from './widget-di.tokens';\\r\\n\\r\\nexport type { WidgetEventManagerFactory } from './widget-di.tokens';\\r\\n\\r\\n// Export custom widget renderer types\\r\\nexport type {\\r\\n  CustomWidgetComponent,\\r\\n  CustomWidgetRenderer,\\r\\n  CustomWidgetHtmlRenderer,\\r\\n  CustomWidgetRendererConfig,\\r\\n  WidgetTemplateContext,\\r\\n} from './custom-widget-renderer.types';\\r\\n\\r\\nexport {\\r\\n  isHtmlRenderer,\\r\\n  isComponentRenderer,\\r\\n  isTemplateRenderer,\\r\\n} from './custom-widget-renderer.types';\\r\\n\\r\\n// Re-export commonly used types and classes from core package\\r\\nexport {\\r\\n  ChatWidget,\\r\\n} from '@bbq-chat/widgets';\\r\\n\\r\\nexport type {\\r\\n  ButtonWidget,\\r\\n  CardWidget,\\r\\n  FormWidget,\\r\\n  InputWidget,\\r\\n  TextAreaWidget,\\r\\n  DropdownWidget,\\r\\n  SliderWidget,\\r\\n  ToggleWidget,\\r\\n  FileUploadWidget,\\r\\n  DatePickerWidget,\\r\\n  MultiSelectWidget,\\r\\n  ProgressBarWidget,\\r\\n  ThemeSwitcherWidget,\\r\\n  ImageWidget,\\r\\n  ImageCollectionWidget,\\r\\n} from '@bbq-chat/widgets';\\r\\n\\r\\n// Re-export utilities\\r\\nexport {\\r\\n  SsrWidgetRenderer,\\r\\n  WidgetEventManager,\\r\\n  customWidgetRegistry,\\r\\n} from '@bbq-chat/widgets';\\r\\n\\r\\n// Version\\r\\nexport const VERSION = '1.0.2';\\r\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public_api';\\n\"],\"names\":[\"i1.WidgetRegistryService\"],\"mappings\":\";;;;;;;AAkEA;;AAEG;AACG,SAAU,kBAAkB,CAChC,QAA8B,EAAA;IAE9B,QACE,QAAQ,KAAK,IAAI;QACjB,OAAO,QAAQ,KAAK,QAAQ;QAC5B,oBAAoB,IAAI,QAAQ;AAEpC;AAEA;;;;;;;;;;;;AAYG;AACG,SAAU,mBAAmB,CACjC,QAA8B,EAAA;;AAG9B,IAAA,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE;AAClC,QAAA,OAAO,KAAK;IACd;;;AAIA,IAAA,QACE,QAAQ,CAAC,SAAS,KAAK,SAAS;AAChC,QAAA,QAAQ,CAAC,SAAS,CAAC,WAAW,KAAK,QAAQ;AAC3C,QAAA,QAAQ,CAAC,MAAM,KAAK,CAAC;;AAEzB;AAEA;;;;;AAKG;AACG,SAAU,cAAc,CAC5B,QAA8B,EAAA;AAE9B,IAAA,OAAO,OAAO,QAAQ,KAAK,UAAU;AACvC;;MCpGa,4BAA4B,GAAG,IAAI,cAAc,CAC5D,8BAA8B;AAGhC;;;;;;;;;;;AAWG;MACU,mBAAmB,GAAG,IAAI,cAAc,CACnD,qBAAqB;AAGvB;;;;;;;AAOG;SACa,iCAAiC,GAAA;IAC/C,OAAO,CAAC,aAAoC,KAAK,IAAI,kBAAkB,CAAC,aAAa,CAAC;AACxF;AAEA;;;;;;;;AAQG;SACa,wBAAwB,GAAA;IACtC,OAAO,IAAI,iBAAiB,EAAE;AAChC;;AC1DA;;;;;;;;;;;;;;;;;;;;;;AAsBG;MAIU,qBAAqB,CAAA;AACf,IAAA,eAAe,GAAG,IAAI,GAAG,EAAgC;AAC1E;;;;;AAKG;IACH,eAAe,CACb,IAAY,EACZ,OAA4C,EAAA;AAE5C,QAAA,oBAAoB,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC;IACrD;AAEA;;;;;AAKG;IACH,aAAa,CAAC,IAAY,EAAE,IAAS,EAAA;AACnC,QAAA,oBAAoB,CAAC,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC;IAChD;AAEA;;;;;AAKG;AACH,IAAA,UAAU,CAAC,IAAY,EAAA;AACrB,QAAA,OAAO,oBAAoB,CAAC,UAAU,CAAC,IAAI,CAAC;IAC9C;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBG;IACH,gBAAgB,CAAC,IAAY,EAAE,QAA8B,EAAA;QAC3D,IAAI,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AACrC,YAAA,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC;QACpD;QACA,IAAI,CAAC,QAAQ,EAAE;AACb,YAAA,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC;QACzC;QACA,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC;IAC1C;AAEA;;;;;AAKG;AACH,IAAA,WAAW,CAAC,IAAY,EAAA;QACtB,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC;IACvC;AAEA;;;;;AAKG;AACH,IAAA,WAAW,CAAC,IAAY,EAAA;QACtB,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC;IACvC;AAEA;;;;;AAKG;AACH,IAAA,kBAAkB,CAAC,IAAY,EAAA;QAC7B,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC;IAC1C;uGAhGW,qBAAqB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA;AAArB,IAAA,OAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,qBAAqB,cAFpB,MAAM,EAAA,CAAA;;2FAEP,qBAAqB,EAAA,UAAA,EAAA,CAAA;kBAHjC,UAAU;AAAC,YAAA,IAAA,EAAA,CAAA;AACV,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;;;ACYD;;;;;;;;;;;;;;;;;;AAkBG;MAgCU,uBAAuB,CAAA;AAgCO,IAAA,QAAA;AACS,IAAA,mBAAA;AACtC,IAAA,cAAA;AACA,IAAA,QAAA;AACA,IAAA,mBAAA;AAjCZ;;AAEG;AACM,IAAA,OAAO;AAEhB;;AAEG;AACO,IAAA,YAAY,GAAG,IAAI,YAAY,EAGrC;AAGJ,IAAA,YAAY;IAEF,WAAW,GAKhB,EAAE;AAEG,IAAA,YAAY;IACZ,iBAAiB,GAAG,KAAK;IACzB,iBAAiB,GAA6B,EAAE;IAChD,YAAY,GAAkD,EAAE;IAE1E,WAAA,CACyC,QAA2B,EAClB,mBAA8C,EACpF,cAAqC,EACrC,QAAkB,EAClB,mBAAwC,EAAA;QAJX,IAAA,CAAA,QAAQ,GAAR,QAAQ;QACC,IAAA,CAAA,mBAAmB,GAAnB,mBAAmB;QACzD,IAAA,CAAA,cAAc,GAAd,cAAc;QACd,IAAA,CAAA,QAAQ,GAAR,QAAQ;QACR,IAAA,CAAA,mBAAmB,GAAnB,mBAAmB;IAC5B;IAEH,QAAQ,GAAA;;IAER;AAEA,IAAA,WAAW,CAAC,OAAsB,EAAA;AAChC,QAAA,IAAI,OAAO,CAAC,SAAS,CAAC,EAAE;YACtB,IAAI,CAAC,gBAAgB,EAAE;QACzB;IACF;IAEA,eAAe,GAAA;QACb,IAAI,CAAC,gBAAgB,EAAE;AACvB,QAAA,IAAI,CAAC,iBAAiB,GAAG,IAAI;QAC7B,IAAI,CAAC,kBAAkB,EAAE;;QAEzB,IAAI,CAAC,oBAAoB,EAAE;IAC7B;IAEA,WAAW,GAAA;QACT,IAAI,CAAC,OAAO,EAAE;IAChB;AAEA;;;;;;;;AAQG;IACO,gBAAgB,GAAA;AACxB,QAAA,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAC9C,YAAA,IAAI,CAAC,WAAW,GAAG,EAAE;YACrB;QACF;AAEA,QAAA,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,KAAI;AACpD,YAAA,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC;;AAGnE,YAAA,IAAI,cAAc,IAAI,kBAAkB,CAAC,cAAc,CAAC,EAAE;gBACxD,OAAO;oBACL,KAAK;oBACL,MAAM;AACN,oBAAA,MAAM,EAAE,KAAK;iBACd;YACH;;AAGA,YAAA,IAAI,cAAc,IAAI,mBAAmB,CAAC,cAAc,CAAC,EAAE;gBACzD,OAAO;oBACL,KAAK;oBACL,MAAM;AACN,oBAAA,MAAM,EAAE,KAAK;iBACd;YACH;;AAGA,YAAA,IAAI,cAAc,IAAI,cAAc,CAAC,cAAc,CAAC,EAAE;gBACpD,OAAO;oBACL,KAAK;oBACL,MAAM;AACN,oBAAA,MAAM,EAAE,IAAI;AACZ,oBAAA,IAAI,EAAE,cAAc,CAAC,MAAM,CAAC;iBAC7B;YACH;;YAGA,OAAO;gBACL,KAAK;gBACL,MAAM;AACN,gBAAA,MAAM,EAAE,IAAI;gBACZ,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC;aACzC;AACH,QAAA,CAAC,CAAC;;AAGF,QAAA,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,UAAU,CAAC,MAAK;gBACd,IAAI,CAAC,kBAAkB,EAAE;gBACzB,IAAI,CAAC,oBAAoB,EAAE;YAC7B,CAAC,EAAE,CAAC,CAAC;QACP;IACF;AAEA;;AAEG;IACO,oBAAoB,GAAA;AAC5B,QAAA,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,aAAa;YAAE;;AAGvC,QAAA,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAK;AAC1B,YAAA,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,aAAa;gBAAE;;YAGvC,IAAI,CAAC,qBAAqB,EAAE;AAE5B,YAAA,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa;;AAEjD,YAAA,MAAM,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAClC,SAAS,CAAC,gBAAgB,CAAC,aAAa,CAAC,CACzB;YAElB,IAAI,YAAY,GAAG,CAAC;YACpB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AAChC,gBAAA,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AAChB,oBAAA,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;AAExE,oBAAA,IAAI,CAAC,cAAc;wBAAE;AAErB,oBAAA,MAAM,SAAS,GAAG,iBAAiB,CAAC,YAAY,CAAC;AACjD,oBAAA,IAAI,CAAC,SAAS;wBAAE;;AAGhB,oBAAA,SAAS,CAAC,SAAS,GAAG,EAAE;AAExB,oBAAA,IAAI,mBAAmB,CAAC,cAAc,CAAC,EAAE;wBACvC,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC;oBAC9D;AAAO,yBAAA,IAAI,kBAAkB,CAAC,cAAc,CAAC,EAAE;wBAC7C,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC;oBAC7D;AAEA,oBAAA,YAAY,EAAE;gBAChB;AACF,YAAA,CAAC,CAAC;AACJ,QAAA,CAAC,CAAC;IACJ;AAEA;;;;;;;AAOG;AACO,IAAA,eAAe,CACvB,aAAkB,EAClB,MAAkB,EAClB,aAA0B,EAAA;;AAG1B,QAAA,MAAM,YAAY,GAAG,eAAe,CAAC,aAAa,EAAE;YAClD,mBAAmB,EAAE,IAAI,CAAC,mBAAmB;YAC7C,eAAe,EAAE,IAAI,CAAC,QAAQ;AAC/B,SAAA,CAAC;;AAGF,QAAA,MAAM,QAAQ,GAAG,YAAY,CAAC,QAAQ;AACtC,QAAA,IAAI,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;;AAE5C,YAAA,IAAI,QAAQ,IAAI,QAAQ,EAAE;AACvB,gBAAA,QAAgB,CAAC,MAAM,GAAG,MAAM;YACnC;;AAGA,YAAA,IAAI,cAAc,IAAI,QAAQ,EAAE;gBAC7B,QAAgB,CAAC,YAAY,GAAG,CAAC,UAAkB,EAAE,OAAgB,KAAI;oBACxE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,OAAO,EAAE,CAAC;AACjD,gBAAA,CAAC;YACH;QACF;;QAGA,aAAa,CAAC,WAAW,CAAC,YAAY,CAAC,QAAQ,CAAC,aAAa,CAAC;;AAG9D,QAAA,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,YAAY,CAAC;;AAGzC,QAAA,YAAY,CAAC,iBAAiB,EAAE,aAAa,EAAE;IACjD;AAEA;;AAEG;AACO,IAAA,cAAc,CACtB,WAA+C,EAC/C,MAAkB,EAClB,aAA0B,EAAA;AAE1B,QAAA,MAAM,OAAO,GAA0B;AACrC,YAAA,SAAS,EAAE,MAAM;AACjB,YAAA,MAAM,EAAE,MAAM;AACd,YAAA,UAAU,EAAE,CAAC,UAAkB,EAAE,OAAgB,KAAI;gBACnD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,OAAO,EAAE,CAAC;YACjD,CAAC;SACF;QAED,MAAM,OAAO,GAAG,WAAW,CAAC,kBAAkB,CAAC,OAAO,CAAC;;QAGvD,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,IAAU,KAAI;AACvC,YAAA,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC;AACjC,QAAA,CAAC,CAAC;;AAGF,QAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC;;QAG/B,OAAO,CAAC,aAAa,EAAE;IACzB;AAEA;;AAEG;IACO,qBAAqB,GAAA;QAC7B,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,YAAY,KAAI;YAC9C,YAAY,CAAC,OAAO,EAAE;AACxB,QAAA,CAAC,CAAC;AACF,QAAA,IAAI,CAAC,iBAAiB,GAAG,EAAE;QAE3B,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,OAAO,KAAI;YACpC,OAAO,CAAC,OAAO,EAAE;AACnB,QAAA,CAAC,CAAC;AACF,QAAA,IAAI,CAAC,YAAY,GAAG,EAAE;IACxB;IAEQ,kBAAkB,GAAA;AACxB,QAAA,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,aAAa;YAAE;;QAGvC,IAAI,CAAC,OAAO,EAAE;AAEd,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa;;AAGjD,QAAA,MAAM,aAAa,GAAG;AACpB,YAAA,MAAM,EAAE,OAAO,MAAc,EAAE,OAAY,KAAI;AAC7C,gBAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC;YACzD,CAAC;SACF;;QAGD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC;AAC3D,QAAA,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,SAAS,CAAC;IAC7C;AAEA,IAAA,WAAW,CAAC,KAAiB,EAAA;AAC3B,QAAA,MAAM,MAAM,GAAG,KAAK,CAAC,MAAqB;;;QAG1C,MAAM,MAAM,GAAG,MAAM,CAAC,OAAO,KAAK,QAAQ,GAAG,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QAC9E,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,2BAA2B,CAAC,EAAE;YAC1D,MAAM,UAAU,GAAG,MAAM,CAAC,YAAY,CAAC,aAAa,CAAC;YACrD,IAAI,UAAU,EAAE;AACd,gBAAA,IAAI;oBACF,MAAM,UAAU,GAAG,MAAM,CAAC,YAAY,CAAC,cAAc,CAAC;AACtD,oBAAA,MAAM,OAAO,GAAG,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,EAAE;oBACxD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,OAAO,EAAE,CAAC;gBACjD;gBAAE,OAAO,GAAG,EAAE;AACZ,oBAAA,OAAO,CAAC,KAAK,CAAC,wCAAwC,EAAE,GAAG,CAAC;gBAC9D;YACF;QACF;IACF;AAEA;;AAEG;IACK,OAAO,GAAA;;QAEb,IAAI,CAAC,qBAAqB,EAAE;;AAG5B,QAAA,IAAI,CAAC,YAAY,GAAG,SAAS;IAC/B;uGAnTW,uBAAuB,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAgCxB,mBAAmB,EAAA,EAAA,EAAA,KAAA,EACnB,4BAA4B,EAAA,EAAA,EAAA,KAAA,EAAAA,qBAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,QAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,mBAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA;AAjC3B,IAAA,OAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,IAAA,EAAA,uBAAuB,EAAA,YAAA,EAAA,IAAA,EAAA,QAAA,EAAA,qBAAA,EAAA,MAAA,EAAA,EAAA,OAAA,EAAA,SAAA,EAAA,EAAA,OAAA,EAAA,EAAA,YAAA,EAAA,cAAA,EAAA,EAAA,SAAA,EA3BvB;AACT,YAAA,EAAE,OAAO,EAAE,4BAA4B,EAAE,UAAU,EAAE,iCAAiC,EAAE;AACxF,YAAA,EAAE,OAAO,EAAE,mBAAmB,EAAE,UAAU,EAAE,wBAAwB,EAAE;SACvE,EAAA,WAAA,EAAA,CAAA,EAAA,YAAA,EAAA,cAAA,EAAA,KAAA,EAAA,IAAA,EAAA,SAAA,EAAA,CAAA,iBAAA,CAAA,EAAA,WAAA,EAAA,IAAA,EAAA,CAAA,EAAA,aAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,QAAA,EACS,CAAA;;;;;;;;;;AAUT,EAAA,CAAA,EAAA,QAAA,EAAA,IAAA,EAAA,MAAA,EAAA,CAAA,4EAAA,CAAA,EAAA,YAAA,EAAA,CAAA,EAAA,IAAA,EAAA,UAAA,EAAA,IAAA,EAfS,YAAY,EAAA,CAAA,EAAA,CAAA;;2FA4BX,uBAAuB,EAAA,UAAA,EAAA,CAAA;kBA/BnC,SAAS;AACE,YAAA,IAAA,EAAA,CAAA,EAAA,QAAA,EAAA,qBAAqB,cACnB,IAAI,EAAA,OAAA,EACP,CAAC,YAAY,CAAC,EAAA,SAAA,EACZ;AACT,wBAAA,EAAE,OAAO,EAAE,4BAA4B,EAAE,UAAU,EAAE,iCAAiC,EAAE;AACxF,wBAAA,EAAE,OAAO,EAAE,mBAAmB,EAAE,UAAU,EAAE,wBAAwB,EAAE;qBACvE,EAAA,QAAA,EACS,CAAA;;;;;;;;;;AAUT,EAAA,CAAA,EAAA,MAAA,EAAA,CAAA,4EAAA,CAAA,EAAA;;0BA6CE,MAAM;2BAAC,mBAAmB;;0BAC1B,MAAM;2BAAC,4BAA4B;;sBA3BrC;;sBAKA;;sBAKA,SAAS;AAAC,gBAAA,IAAA,EAAA,CAAA,iBAAiB,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE;;;AC3GjD;;;;;;;;;;AAUG;AAEH;AA6DA;AACO,MAAM,OAAO,GAAG;;AC1EvB;;AAEG;;;;\"}","type":"asset"}]}