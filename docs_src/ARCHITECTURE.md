# Architecture Guide

BbQ.ChatWidgets is designed as a distributed system that coordinates between a .NET backend and a JavaScript-based frontend. This guide explains the core components and the data flow between them.

## High-Level Overview

The system follows a "Server-Driven UI" pattern for chat. The LLM decides which widgets are appropriate for the conversation, and the server provides the metadata and templates required for the frontend to render them.

### Core Components

#### 1. Server-Side (.NET)

- **`ChatWidgetService`**: The central orchestrator. It manages conversation threads, interacts with the `IChatClient`, parses widget hints from AI responses, dispatches widget actions, and manages context window limits through automatic chat history summarization.
- **`WidgetRegistry`**: A catalog of available widget templates. Each widget (e.g., `ButtonWidget`, `FormWidget`) is registered here as a live instance.
- **`IThreadService`**: Manages conversation history and summaries. The default implementation is in-memory (`DefaultThreadService`), but it can be replaced with a persistent store.
- **`IChatHistorySummarizer`**: Generates concise summaries of older conversation turns to manage context window size. The default implementation uses the AI client.
- **`IWidgetActionRegistry`**: Maps widget actions (e.g., "submit_form") to their corresponding server-side handlers.
- **`IAIInstructionProvider`**: Generates the system prompt that tells the LLM how to use widgets and what actions are available.

#### 2. Client-Side (JavaScript/TypeScript)

- **`WidgetManager`**: The primary entry point for rendering widgets. It maintains a registry of component renderers and handles the lifecycle of widgets in the DOM.
- **`WidgetSseManager`**: Handles real-time server-pushed updates for widgets via Server-Sent Events (SSE).
- **Action Dispatcher**: Forwards user interactions (like clicking a button or submitting a form) back to the server's `/api/chat/action` endpoint.

## Data Flow

### 1. Message Request
1. The frontend sends a `POST` request to `/api/chat/message` with the user's text.
2. `ChatWidgetService` retrieves the conversation history from `IThreadService`.
3. If auto-summarization is enabled and the conversation exceeds the threshold, older turns are summarized using `IChatHistorySummarizer`.
4. It calls the `IChatClient` (e.g., OpenAI) with the history (including summaries + recent turns) and a system prompt generated by `IAIInstructionProvider`.
5. The LLM responds, potentially including `<widget>...</widget>` tags or calling the `get_widget_tools` function.
6. `ChatWidgetService` parses these hints, creates the widget metadata, and returns a `ChatTurn` object containing the text and the list of widgets.

### 2. Widget Action
1. The user interacts with a widget (e.g., clicks a "Confirm" button).
2. The frontend sends a `POST` request to `/api/chat/action` with the action name and payload.
3. `ChatWidgetService` resolves the appropriate handler via `IWidgetActionHandlerResolver`.
4. The handler executes (e.g., updates a database) and returns a response.
5. The response is appended to the conversation thread, and the updated state is returned to the client.

### 3. Streaming (SSE)
1. The frontend connects to `/api/chat/stream/message`.
2. The server streams `ChatTurn` deltas as they are generated by the LLM.
3. The final event in the stream contains the full `ChatTurn` with all resolved widgets.

## Extension Points

BbQ.ChatWidgets is highly extensible. You can swap out almost any component by providing your own implementation of the core interfaces:

- **Custom Widgets**: Implement `IChatWidget` and register it in the `WidgetRegistry`.
- **Custom Persistence**: Implement `IThreadService` to store conversations and summaries in SQL, NoSQL, or Redis.
- **Custom Summarization**: Implement `IChatHistorySummarizer` to use custom logic, templates, or different AI models for summarization.
- **Custom AI Logic**: Replace `IAIInstructionProvider` or `IAIToolsProvider` to change how the LLM is guided.

## Context Management

The system includes automatic chat history summarization to manage context window limits:

- **Threshold-Based**: Automatically triggers when conversation turns exceed a configurable threshold
- **Smart Summarization**: Older turns are condensed into summaries while recent turns remain in full detail
- **Configurable**: Set thresholds, enable/disable, and customize summarization behavior
- **Extensible**: Implement custom `IChatHistorySummarizer` for domain-specific summarization logic

For more details, see the [Chat History Summarization Guide](guides/CHAT_HISTORY_SUMMARIZATION.md).
