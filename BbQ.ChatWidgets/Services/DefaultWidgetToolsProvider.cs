using BbQ.ChatWidgets.Abstractions;
using BbQ.ChatWidgets.Models;

namespace BbQ.ChatWidgets.Services;

/// <summary>
/// Default implementation of <see cref="IWidgetToolsProvider"/> that provides AI tools
/// for all available widget instances registered in the widget registry.
/// </summary>
/// <remarks>
/// This provider creates tools by wrapping each registered widget instance in a WidgetTool.
/// Tools are generated dynamically from the <see cref="IWidgetRegistry"/>, which means:
/// - All registered widgets (both built-in and custom) are automatically included
/// - New widgets registered at runtime are immediately available to the AI
/// - The registry is the single source of truth for available widget instances
/// - No metadata extraction needed â€” instances provide all required information
/// </remarks>
public sealed class DefaultWidgetToolsProvider : IWidgetToolsProvider
{
    private readonly IWidgetRegistry _registry;
    private IReadOnlyList<WidgetTool>? _cachedTools;

    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultWidgetToolsProvider"/> class.
    /// </summary>
    /// <param name="registry">The widget registry to use for discovering available widgets.</param>
    /// <exception cref="ArgumentNullException">Thrown if registry is null.</exception>
    public DefaultWidgetToolsProvider(IWidgetRegistry registry)
    {
        _registry = registry ?? throw new ArgumentNullException(nameof(registry));
    }

    /// <summary>
    /// Gets the list of available widget tools for use by AI models.
    /// </summary>
    /// <returns>A read-only list of WidgetTool instances representing all registered widgets.</returns>
    /// <remarks>
    /// Tools are generated by wrapping each registered widget instance and cached
    /// after the first call for performance.
    /// </remarks>
    public IReadOnlyList<WidgetTool> GetTools()
    {
        if (_cachedTools != null)
            return _cachedTools;

        var tools = new List<WidgetTool>();

        // Create tools from all registered widget instances
        foreach (var instance in _registry.GetInstances())
        {
            try
            {
                var tool = new WidgetTool(instance);
                tools.Add(tool);
            }
            catch (Exception ex)
            {
                // Log and skip problematic widgets without breaking the entire provider
                System.Diagnostics.Debug.WriteLine($"Warning: Failed to create tool for widget: {ex.Message}");
            }
        }

        _cachedTools = tools.AsReadOnly();
        return _cachedTools;
    }
}
