# Copilot instructions

## High-level orientation
- The repo ships two products (NuGet `BbQ.ChatWidgets` and npm `@bbq-chat/widgets`) with an extensive `docs/` site; see [README.md](README.md#L1) for the executive summary and quick-start commands.
- Expect a .NET 8 backend plus Node >= 20 frontend/TypeScript toolchain (see the bundled `build.bat`/`build.sh` for the full end-to-end workflow) and the `Sample/WebApp` SPA that exercises the HTTP+SSE surface area.

## Architecture & runtime flow
- `ChatWidgetService` is the central orchestrator: it maintains threads, exposes `get_widget_tools` via `AIFunctionFactory`, parses `<widget>` hints, streams deltas, and dispatches widget actions; refer to [BbQ.ChatWidgets/Services/ChatWidgetService.cs](BbQ.ChatWidgets/Services/ChatWidgetService.cs#L1) for the sequence of responsibilities.
- Dependency setup lives in [BbQ.ChatWidgets/Extensions/ServiceCollectionExtensions.cs](BbQ.ChatWidgets/Extensions/ServiceCollectionExtensions.cs#L1); `AddBbQChatWidgets` wires the widget registry, thread service, SSE service, instruction/tool providers, action metadata, and the HTTP middleware that maps `/api/chat/{message,action,agent}` (plus `/stream/*` and `/widgets/streams/{streamId}/events`).
- Conversation state is just an in-memory `DefaultThreadService` ([DefaultThreadService.cs](BbQ.ChatWidgets/Services/DefaultThreadService.cs#L1)); swap in a persistent `IThreadService` before production to avoid losing history. It also recycles any `IRecyclableWidget` after each append.
- `WidgetRegistry` seeds every built-in widget (buttons, cards, form, file upload, toggles, etc.) and must be populated with actual template instances (not `Type` objects); use `BbQChatOptions.WidgetRegistryConfigurator` to add custom templates, then let `DefaultWidgetToolsProvider` turn every registry entry into a `WidgetTool` for the LLM ([WidgetRegistry.cs](BbQ.ChatWidgets/Services/WidgetRegistry.cs#L1), [DefaultWidgetToolsProvider.cs](BbQ.ChatWidgets/Services/DefaultWidgetToolsProvider.cs#L1)).
- The default instruction provider synthesizes system prompts from the widget registry and registered actions, and it includes a hard rule: input-like widgets (Input, Dropdown, Slider, Toggle, FileUpload, DatePicker, MultiSelect) must live inside a `FormWidget`, and all widgets must stay inside `<widget>...</widget>` markers ([DefaultInstructionProvider.cs](BbQ.ChatWidgets/Services/DefaultInstructionProvider.cs#L1)).
- Widget actions are catalogued by `DefaultWidgetActionRegistry`/`DefaultWidgetActionHandlerResolver`, and the `IWidgetRegistry.RegisterHandler<TAction,TPayload,THandler>` extension bundles metadata + handler registration. Register every action via that helper so `HandleActionAsync` can deserialize payloads, resolve the handler, and append the response to the same thread ([WidgetActionHandlerResolver.cs](BbQ.ChatWidgets/Services/WidgetActionHandlerResolver.cs#L1)).
- SSE is backed by `WidgetSseService`: subscribe with `GET {prefix}/widgets/streams/{streamId}/events` and publish via `POST` to the same route. The service uses `ChannelWriter`s for each client and sends JSON payloads with `data:` frames, which the sample `ClockPublisher` drives to demo server-pushed widgets ([WidgetSseService.cs](BbQ.ChatWidgets/Services/WidgetSseService.cs#L1), [Sample/WebApp/Services/ClockPublisher.cs](Sample/WebApp/Services/ClockPublisher.cs#L1)).
- Triage routing relies on `TriageAgent<TCategory>` and the sample setups: register classifiers + specialized agents, then call `AddTriageAgentSystem()` in the console sample or `AddWebAppTriageAgents()` in the web API before sending requests through `MapBbQChatEndpoints` ([BbQ.ChatWidgets.Sample/TriageAgentSetup.cs](BbQ.ChatWidgets.Sample/TriageAgentSetup.cs#L1), [Sample/WebApp/Agents/WebAppTriageSetup.cs](Sample/WebApp/Agents/WebAppTriageSetup.cs#L1)). The agent stores the user message, classification, and routed agent in `InterAgentCommunicationContext`, so downstream handlers can read metadata.

## Workflows & tooling
- `build.bat`/`build.sh` run `dotnet build -c Release`, verify `dotnet` and `npm`, and explain how to start the WebApp (`dotnet run` + optionally `npm run dev` in `Sample/WebApp/ClientApp` for HMR). Use the scripts before releases to ensure the React app compiles into `wwwroot` ([build.bat](build.bat#L1), [build.sh](build.sh#L1)).
- Docs/live API generation is scripted in `docs/generate-docs.ps1`: it builds `BbQ.ChatWidgets`, runs `docfx metadata/build` into `docs/`, then hops into `js/` to install dependencies and run the TypeDoc pipeline (`npm run docs:js`). Run this script whenever doc comments change or API surface adjustments are made ([docs/generate-docs.ps1](docs/generate-docs.ps1#L1)).
- Tests are run via `dotnet test` at the repo root (covers `BbQ.ChatWidgets.Tests` with fixtures for widgets/agents) and `npm test` within `Sample/WebApp/ClientApp` (Vitest). Those are the commands relied on by `README.md` for quick verification.
- The console sample (`BbQ.ChatWidgets.Sample/Program.cs`) and web API sample (`Sample/WebApp/Program.cs`) both guard against missing `OpenAI:ApiKey` and build a `ChatClient` with `ChatClientBuilder.UseFunctionInvocation()` so the `get_widget_tools` function works. Mirror this pattern in new apps.

## Patterns & conventions for contributions
- Widgets must be registered as live instances (see `WidgetRegistry` constructor for the built-in catalog) and customise via `BbQChatOptions.WidgetRegistryConfigurator`. Always call `Serialization.SetCustomWidgetRegistry` (done inside `AddBbQChatWidgets`) before introducing a new widget so the parser and tools remain cohesive.
- Register action metadata + handler pairs through the `RegisterHandler<TAction,TPayload,THandler>` extension so `DefaultInstructionProvider` can mention the payload schema and `ChatWidgetService.HandleActionAsync` can resolve the handler predictably ([WidgetActionHandlerResolver.cs](BbQ.ChatWidgets/Services/WidgetActionHandlerResolver.cs#L1), [Sample/WebApp/Actions/SampleActions.cs](Sample/WebApp/Actions/SampleActions.cs#L1), [BbQ.ChatWidgets.Sample/Actions/SampleActions.cs](BbQ.ChatWidgets.Sample/Actions/SampleActions.cs#L1)).
- Use `ServiceCollection` extensions (`AddBbQChatWidgets`, `AddTriageAgentSystem`, `AddWebAppTriageAgents`) to avoid missing registrations; everything in `ServiceCollectionExtensions.cs` is an atomic block of dependencies, endpoint wiring, and serialization rules ([BbQ.ChatWidgets/Extensions/ServiceCollectionExtensions.cs](BbQ.ChatWidgets/Extensions/ServiceCollectionExtensions.cs#L1)).
- If you need extra AI capabilities beyond widgets, replace `IAIToolsProvider` via `BbQChatOptions.ToolProviderFactory`; the default currently only supplies a `retry_tool` ([DefaultAIToolsProvider.cs](BbQ.ChatWidgets/Services/DefaultAIToolsProvider.cs#L1)). Similarly, swap `IAIInstructionProvider` if the default widget + action instructions are not enough.
- For triage metadata, rely on `InterAgentCommunicationContext`—the samples show how to stash the raw user message, classification, and routed agent so each downstream agent or controller can log or respond with the same context ([Sample/WebApp/Agents/SpecializedAgents.cs](Sample/WebApp/Agents/SpecializedAgents.cs#L1)).

## Streaming, SSE, and custom widget demos
- Streaming responses are delivered via `ChatWidgetService.StreamResponseAsync`, which yields delta turns (IsDelta flag) before the final message is appended to the `DefaultThreadService`. Use the `POST {prefix}/stream/*` endpoints to pipe these deltas to clients ([BbQ.ChatWidgets/Services/ChatWidgetService.cs](BbQ.ChatWidgets/Services/ChatWidgetService.cs#L1), [BbQ.ChatWidgets/Extensions/ServiceCollectionExtensions.cs](BbQ.ChatWidgets/Extensions/ServiceCollectionExtensions.cs#L1)).
- The web API sample mutates the widget registry to add an `EChartsWidget` and a `ClockWidget`; the latter subscribes to SSE via `ClockPublisher` to show real-time server pushes. Follow that example when wiring new SSE-driven widgets ([Sample/WebApp/Models/EChartsWidget.cs](Sample/WebApp/Models/EChartsWidget.cs#L1), [Sample/WebApp/Models/ClockWidget.cs](Sample/WebApp/Models/ClockWidget.cs#L1)).

## Documentation & resources
- API docs live in the `docs/` directory produced by DocFX and TypeDoc; if you regenerate them, `docs/generate-docs.ps1` also updates `docs/js/` with the JS/TS reference. Publishing the repo to GH Pages expects those outputs under `docs/`.
- The `README.md` keeps quick start, testing, and feature highlights in sync with packaged release notes; update it when you change public APIs or sample instructions.

Please review these notes—flag any gaps or confusion so I can refine the instructions further.